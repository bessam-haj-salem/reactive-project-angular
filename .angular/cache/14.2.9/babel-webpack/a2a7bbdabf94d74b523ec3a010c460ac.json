{"ast":null,"code":"import { ɵglobal } from '@angular/core';\nimport { Observable, from, combineLatest } from 'rxjs';\nimport { concatMap, mapTo, filter, distinctUntilChanged, map, shareReplay } from 'rxjs/operators';\nimport { coalesceWith } from '@rx-angular/cdk/coalescing';\n\nfunction getZoneUnPatchedApi(targetOrName, name) {\n  // If the user has provided the API name as the first argument, for instance:\n  // `const addEventListener = getZoneUnPatchedApi('addEventListener');`\n  // Then we just swap arguments and make `global` or `window` as the default target.\n  if (typeof targetOrName === 'string') {\n    name = targetOrName;\n    targetOrName = ɵglobal;\n  }\n\n  return targetOrName['__zone_symbol__' + name] || targetOrName[name];\n}\n/**\n * Creates an Observable that emits after a setTimeout.\n * The timeout it unpatched to not avoid zone pollution\n * @param setTimeoutFn\n */\n\n\nfunction timeout(delay = 0) {\n  return new Observable(subscriber => {\n    const asyncID = getZoneUnPatchedApi('setTimeout')(() => subscriber.next(0), delay);\n    return () => {\n      getZoneUnPatchedApi('clearTimeout')(asyncID);\n    };\n  });\n}\n/**\n *\n */\n\n\nfunction timeoutSwitchMapWith() {\n  return o$ => o$.pipe(concatMap(v => timeout().pipe(mapTo(v))));\n}\n\nconst resolvedPromise = getZoneUnPatchedApi('Promise').resolve();\nconst resolvedPromise$ = from(resolvedPromise);\n/**\n * @internal\n *\n * Used for typing\n */\n\nfunction getEntriesToObjectReducerFn(keys) {\n  return (accumulator, currentValue, currentIndex) => {\n    return Object.assign(Object.assign({}, accumulator), {\n      [keys[currentIndex]]: currentValue\n    });\n  };\n}\n/**\n * This Observable creation function helps to accumulate an object of key & Observable of values to\n * an Observable of objects of key & value.\n * This comes in handy if you quickly want to create subsets as objects/state-slices of different Observables.\n *\n * The resulting Observable filters out undefined values forwards only distinct values and shared the aggregated output.\n *\n * @example\n *\n * Default usage:\n *\n * const object$: Observable<{\n *   prop1: number,\n *   prop2: string,\n *   prop3: string\n * }> = accumulateObservables({\n *   prop1: interval(42),\n *   prop2: of('lorem'),\n *   prop3: 'test'\n * });\n *\n * Usage with custom duration selector:\n *\n * const object$: Observable<{\n *   prop1: number,\n *   prop2: string,\n *   prop3: string\n * }> = accumulateObservables({\n *   prop1: interval(42),\n *   prop2: of('lorem'),\n *   prop3: 'test'\n * }, timer(0, 20));\n *\n * @param obj - An object of key & Observable values pairs\n * @param durationSelector - An Observable determining the duration for the internal coalescing method\n */\n\n\nfunction accumulateObservables( // @TODO type static or Observable to enable mixing of imperative and reatctive values\nobj, durationSelector = resolvedPromise$) {\n  const keys = Object.keys(obj); // @TODO better typing to enable static values => coerceObservable(obj[key])\n\n  const observables = keys.map(key => obj[key].pipe( // we avoid using the nullish operator later ;)\n  filter(v => v !== undefined), // state \"changes\" differ from each other, this operator ensures distinct values\n  distinctUntilChanged()));\n  return combineLatest(observables).pipe( // As combineLatest will emit multiple times for a change in multiple properties we coalesce those emissions\n  // together\n  coalesceWith(durationSelector), // mapping array of values to object\n  map(values => values.reduce(getEntriesToObjectReducerFn(keys), {})), // by using shareReplay we share the last composition work done to create the accumulated object\n  shareReplay({\n    refCount: true,\n    bufferSize: 1\n  }));\n}\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { accumulateObservables, getZoneUnPatchedApi, timeoutSwitchMapWith };","map":{"version":3,"names":["ɵglobal","Observable","from","combineLatest","concatMap","mapTo","filter","distinctUntilChanged","map","shareReplay","coalesceWith","getZoneUnPatchedApi","targetOrName","name","timeout","delay","subscriber","asyncID","next","timeoutSwitchMapWith","o$","pipe","v","resolvedPromise","resolve","resolvedPromise$","getEntriesToObjectReducerFn","keys","accumulator","currentValue","currentIndex","Object","assign","accumulateObservables","obj","durationSelector","observables","key","undefined","values","reduce","refCount","bufferSize"],"sources":["/home/bessam/Documents/Medisail/angular/angular interview/reactive-project-angular/node_modules/@rx-angular/cdk/fesm2015/cdk-internals-core.js"],"sourcesContent":["import { ɵglobal } from '@angular/core';\nimport { Observable, from, combineLatest } from 'rxjs';\nimport { concatMap, mapTo, filter, distinctUntilChanged, map, shareReplay } from 'rxjs/operators';\nimport { coalesceWith } from '@rx-angular/cdk/coalescing';\n\nfunction getZoneUnPatchedApi(targetOrName, name) {\n    // If the user has provided the API name as the first argument, for instance:\n    // `const addEventListener = getZoneUnPatchedApi('addEventListener');`\n    // Then we just swap arguments and make `global` or `window` as the default target.\n    if (typeof targetOrName === 'string') {\n        name = targetOrName;\n        targetOrName = ɵglobal;\n    }\n    return targetOrName['__zone_symbol__' + name] || targetOrName[name];\n}\n\n/**\n * Creates an Observable that emits after a setTimeout.\n * The timeout it unpatched to not avoid zone pollution\n * @param setTimeoutFn\n */\nfunction timeout(delay = 0) {\n    return new Observable((subscriber) => {\n        const asyncID = getZoneUnPatchedApi('setTimeout')(() => subscriber.next(0), delay);\n        return () => {\n            getZoneUnPatchedApi('clearTimeout')(asyncID);\n        };\n    });\n}\n/**\n *\n */\nfunction timeoutSwitchMapWith() {\n    return (o$) => o$.pipe(concatMap((v) => timeout().pipe(mapTo(v))));\n}\n\nconst resolvedPromise = getZoneUnPatchedApi('Promise').resolve();\nconst resolvedPromise$ = from(resolvedPromise);\n/**\n * @internal\n *\n * Used for typing\n */\nfunction getEntriesToObjectReducerFn(keys) {\n    return (accumulator, currentValue, currentIndex) => {\n        return Object.assign(Object.assign({}, accumulator), { [keys[currentIndex]]: currentValue });\n    };\n}\n/**\n * This Observable creation function helps to accumulate an object of key & Observable of values to\n * an Observable of objects of key & value.\n * This comes in handy if you quickly want to create subsets as objects/state-slices of different Observables.\n *\n * The resulting Observable filters out undefined values forwards only distinct values and shared the aggregated output.\n *\n * @example\n *\n * Default usage:\n *\n * const object$: Observable<{\n *   prop1: number,\n *   prop2: string,\n *   prop3: string\n * }> = accumulateObservables({\n *   prop1: interval(42),\n *   prop2: of('lorem'),\n *   prop3: 'test'\n * });\n *\n * Usage with custom duration selector:\n *\n * const object$: Observable<{\n *   prop1: number,\n *   prop2: string,\n *   prop3: string\n * }> = accumulateObservables({\n *   prop1: interval(42),\n *   prop2: of('lorem'),\n *   prop3: 'test'\n * }, timer(0, 20));\n *\n * @param obj - An object of key & Observable values pairs\n * @param durationSelector - An Observable determining the duration for the internal coalescing method\n */\nfunction accumulateObservables(\n// @TODO type static or Observable to enable mixing of imperative and reatctive values\nobj, durationSelector = resolvedPromise$) {\n    const keys = Object.keys(obj);\n    // @TODO better typing to enable static values => coerceObservable(obj[key])\n    const observables = keys.map((key) => obj[key].pipe(\n    // we avoid using the nullish operator later ;)\n    filter((v) => v !== undefined), \n    // state \"changes\" differ from each other, this operator ensures distinct values\n    distinctUntilChanged()));\n    return combineLatest(observables).pipe(\n    // As combineLatest will emit multiple times for a change in multiple properties we coalesce those emissions\n    // together\n    coalesceWith(durationSelector), \n    // mapping array of values to object\n    map((values) => values.reduce(getEntriesToObjectReducerFn(keys), {})), \n    // by using shareReplay we share the last composition work done to create the accumulated object\n    shareReplay({ refCount: true, bufferSize: 1 }));\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { accumulateObservables, getZoneUnPatchedApi, timeoutSwitchMapWith };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}