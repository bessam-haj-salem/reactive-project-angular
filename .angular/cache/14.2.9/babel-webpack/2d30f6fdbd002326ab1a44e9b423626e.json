{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Directive, Input, Output, NgModule } from '@angular/core';\nimport { coerceAllFactory } from '@rx-angular/cdk/coercing';\nimport { createTemplateNotifier } from '@rx-angular/cdk/notifications';\nimport * as i1 from '@rx-angular/cdk/render-strategies';\nimport { RxBaseTemplateNames, createTemplateManager } from '@rx-angular/cdk/template';\nimport { ReplaySubject, Subscription, Subject, defer, merge, NEVER } from 'rxjs';\nimport { map, filter } from 'rxjs/operators';\n/** @internal */\n\nconst RxLetTemplateNames = Object.assign(Object.assign({}, RxBaseTemplateNames), {\n  next: 'nextTpl'\n});\n/**\n * @Directive LetDirective\n *\n * @description\n * In Angular there is one way to handle asynchronous values or streams in the template, the `async` pipe.\n * Even though the async pipe evaluates such values in the template, it is insufficient in many ways.\n * To name a few:\n * * it will only update the template when `NgZone` is also aware of the value change\n * * it leads to over rendering because it can only run global change detection\n * * it leads to too many subscriptions in the template\n * * it is cumbersome to work with values in the template\n *\n * read more about the LetDirective in the [official docs](https://www.rx-angular.io/docs/template/api/let-directive)\n *\n * **Conclusion - Structural directives**\n *\n * In contrast to global change detection, structural directives allow fine-grained control of change detection on a per directive basis.\n * The `LetDirective` comes with its own way to handle change detection in templates in a very efficient way.\n * However, the change detection behavior is configurable on a per directive or global basis.\n * This makes it possible to implement your own strategies, and also provides a migration path from large existing apps running with Angulars default change detection.\n *\n * This package helps to reduce code used to create composable action streams.\n * It mostly is used in combination with state management libs to handle user interaction and backend communication.\n *\n * ```html\n * <ng-container *rxLet=\"observableNumber$; let n\">\n *  ...\n * </ng-container>\n * ```\n *\n *\n * @docsCategory LetDirective\n * @docsPage LetDirective\n * @publicApi\n */\n\nclass LetDirective {\n  constructor(strategyProvider, cdRef, ngZone, nextTemplateRef, viewContainerRef, errorHandler) {\n    this.strategyProvider = strategyProvider;\n    this.cdRef = cdRef;\n    this.ngZone = ngZone;\n    this.nextTemplateRef = nextTemplateRef;\n    this.viewContainerRef = viewContainerRef;\n    this.errorHandler = errorHandler;\n    /**\n     * @description\n     *\n     * When local rendering strategies are used, we need to treat view and content queries in a\n     * special way.\n     * To make `*rxLet` in such situations, a certain mechanism is implemented to\n     * execute change detection on the parent (`parent`).\n     *\n     * This is required if your components state is dependent on its view or content children:\n     *\n     * - `@ViewChild`\n     * - `@ViewChildren`\n     * - `@ContentChild`\n     * - `@ContentChildren`\n     *\n     * Read more about this in the\n     * [official\n     * docs](https://www.rx-angular.io/docs/template/api/let-directive#local-strategies-and-view-content-queries-parent).\n     *\n     * @example\n     * \\@Component({\n     *   selector: 'app-root',\n     *   template: `\n     *    <app-list-component>\n     *      <app-list-item\n     *        *rxLet=\"\n     *          item$;\n     *          let item;\n     *          parent: true;\n     *        \"\n     *      >\n     *        <div>{{ item.name }}</div>\n     *      </app-list-item>\n     *    </app-list-component>\n     *   `\n     * })\n     * export class AppComponent {\n     *   item$ = itemService.getItem();\n     * }\n     *\n     * @param boolean\n     */\n\n    this.renderParent = this.strategyProvider.config.parent;\n    /**\n     * @description\n     * A flag to control whether *rxLet templates are created within `NgZone` or not.\n     * The default value is `true, `*rxLet` will create it's `EmbeddedViews` inside `NgZone`.\n     *\n     * Event listeners normally trigger zone. Especially high frequently events cause performance issues.\n     *\n     * Read more about this in the\n     * [official docs](https://www.rx-angular.io/docs/template/api/let-directive#working-with-event-listeners-patchzone).\n     *\n     * @example\n     * \\@Component({\n     *   selector: 'app-root',\n     *   template: `\n     *    <app-list-component>\n     *      <app-list-item\n     *        *rxLet=\"\n     *          item$;\n     *          let item;\n     *          patchZone: false;\n     *        \"\n     *      >\n     *        <div>{{ item.name }}</div>\n     *      </app-list-item>\n     *    </app-list-component>\n     *   `\n     * })\n     * export class AppComponent {\n     *   item$ = itemService.getItem();\n     * }\n     */\n\n    this.patchZone = this.strategyProvider.config.patchZone;\n    /** @internal */\n\n    this.observablesHandler = createTemplateNotifier();\n    /** @internal */\n\n    this.strategyHandler = coerceAllFactory(() => new ReplaySubject(1));\n    /** @internal */\n\n    this.triggerHandler = new ReplaySubject(1);\n    /** @internal */\n\n    this.subscription = new Subscription();\n    /** @internal */\n\n    this.rendered$ = new Subject();\n    /** @internal */\n\n    this.templateNotification$ = new Subject();\n    /** @internal */\n\n    this.values$ = this.observablesHandler.values$;\n    this.rendered = defer(() => this.rendered$);\n  }\n  /**\n   * @description\n   *\n   * You can change the used `RenderStrategy` by using the `strategy` input of the `*rxLet`. It accepts\n   * an `Observable<RxStrategyNames>` or [`RxStrategyNames`](https://github.com/rx-angular/rx-angular/blob/b0630f69017cc1871d093e976006066d5f2005b9/libs/cdk/render-strategies/src/lib/model.ts#L52).\n   *\n   * The default value for strategy is\n   * [`normal`](https://www.rx-angular.io/docs/template/cdk/render-strategies/strategies/concurrent-strategies).\n   *\n   * Read more about this in the\n   * [official docs](https://www.rx-angular.io/docs/template/api/let-directive#use-render-strategies-strategy).\n   *\n   * @example\n   *\n   * \\@Component({\n   *   selector: 'app-root',\n   *   template: `\n   *     <ng-container *rxLet=\"hero$; let hero; strategy: strategy\">\n   *       <app-hero [hero]=\"hero\"></app-hero>\n   *     </ng-container>\n   *\n   *     <ng-container *rxLet=\"hero$; let hero; strategy: strategy$\">\n   *       <app-hero [hero]=\"hero\"></app-hero>\n   *     </ng-container>\n   *   `\n   * })\n   * export class AppComponent {\n   *   strategy = 'low';\n   *   strategy$ = of('immediate');\n   * }\n   *\n   * @param { string | Observable<string> | undefined } strategyName\n   * @see {@link RxStrategyNames}\n   */\n\n\n  set strategy(strategyName) {\n    this.strategyHandler.next(strategyName);\n  }\n  /**\n   * @description\n   * A `Subject` which emits whenever *rxFor finished rendering a set changes to the view.\n   * This enables developers to perform actions when a list has finished rendering.\n   * The `renderCallback` is useful in situations where you rely on specific DOM properties like the `height` a\n   * table after all items got rendered.\n   * It is also possible to use the renderCallback in order to determine if a view should be visible or not. This\n   * way developers can hide a list as long as it has not finished rendering.\n   *\n   * The result of the `renderCallback` will contain the currently rendered set of items in the iterable.\n   *\n   * @example\n   * \\Component({\n   *   selector: 'app-root',\n   *   template: `\n   *   <app-list-component>\n   *     <app-list-item\n   *       *rxFor=\"\n   *         let item of items$;\n   *         trackBy: trackItem;\n   *         renderCallback: itemsRendered;\n   *       \">\n   *       <div>{{ item.name }}</div>\n   *     </app-list-item>\n   *   </app-list-component>\n   * `\n   * })\n   * export class AppComponent {\n   *   items$: Observable<Item[]> = itemService.getItems();\n   *   trackItem = (idx, item) => item.id;\n   *   // this emits whenever rxFor finished rendering changes\n   *   itemsRendered = new Subject<Item[]>();\n   *\n   *   constructor(elementRef: ElementRef<HTMLElement>) {\n   *     itemsRendered.subscribe(() => {\n   *       // items are rendered, we can now scroll\n   *       elementRef.scrollTo({bottom: 0});\n   *     })\n   *   }\n   * }\n   *\n   * @param {Subject<U>} renderCallback\n   */\n\n\n  set renderCallback(callback) {\n    this._renderObserver = callback;\n  }\n  /** @internal */\n\n\n  static ngTemplateContextGuard(dir, ctx) {\n    return true;\n  }\n  /** @internal */\n\n\n  ngOnInit() {\n    var _a, _b, _c, _d;\n\n    this.subscription.add(this.templateManager.render(merge(this.values$, this.templateNotification$)).subscribe(n => {\n      var _a;\n\n      this.rendered$.next(n);\n      (_a = this._renderObserver) === null || _a === void 0 ? void 0 : _a.next(n);\n    }));\n    this.subscription.add(merge(this.templateTrigger || NEVER, ((_a = this.nextTrigger) === null || _a === void 0 ? void 0 : _a.pipe(map(() => \"next\"\n    /* Next */\n    ))) || NEVER, ((_b = this.suspenseTrigger) === null || _b === void 0 ? void 0 : _b.pipe(map(() => \"suspense\"\n    /* Suspense */\n    ))) || NEVER, ((_c = this.completeTrigger) === null || _c === void 0 ? void 0 : _c.pipe(map(() => \"complete\"\n    /* Complete */\n    ))) || NEVER, ((_d = this.errorTrigger) === null || _d === void 0 ? void 0 : _d.pipe(map(() => \"error\"\n    /* Error */\n    ))) || NEVER).pipe(filter(v => !!v)).subscribe(t => this.triggerHandler.next(t)));\n  }\n  /** @internal */\n\n\n  ngOnChanges(changes) {\n    if (!this.templateManager) {\n      this._createTemplateManager();\n    }\n\n    if (changes.complete) {\n      this.templateManager.addTemplateRef(RxLetTemplateNames.complete, this.complete);\n    }\n\n    if (changes.suspense) {\n      this.templateManager.addTemplateRef(RxLetTemplateNames.suspense, this.suspense);\n      this.observablesHandler.withInitialSuspense(!!this.suspense);\n    }\n\n    if (changes.error) {\n      this.templateManager.addTemplateRef(RxLetTemplateNames.error, this.error);\n    }\n\n    if (changes.rxLet) {\n      this.observablesHandler.next(this.rxLet);\n    }\n  }\n  /** @internal */\n\n\n  ngOnDestroy() {\n    this.subscription.unsubscribe();\n  }\n  /** @internal */\n\n\n  _createTemplateManager() {\n    this.templateManager = createTemplateManager({\n      templateSettings: {\n        viewContainerRef: this.viewContainerRef,\n        customContext: rxLet => ({\n          rxLet\n        })\n      },\n      renderSettings: {\n        cdRef: this.cdRef,\n        parent: !!this.renderParent,\n        patchZone: this.patchZone ? this.ngZone : false,\n        defaultStrategyName: this.strategyProvider.primaryStrategy,\n        strategies: this.strategyProvider.strategies,\n        errorHandler: this.errorHandler\n      },\n      notificationToTemplateName: {\n        [\"suspense\"\n        /* Suspense */\n        ]: () => this.suspense ? RxLetTemplateNames.suspense : RxLetTemplateNames.next,\n        [\"next\"\n        /* Next */\n        ]: () => RxLetTemplateNames.next,\n        [\"error\"\n        /* Error */\n        ]: () => this.error ? RxLetTemplateNames.error : RxLetTemplateNames.next,\n        [\"complete\"\n        /* Complete */\n        ]: () => this.complete ? RxLetTemplateNames.complete : RxLetTemplateNames.next\n      },\n      templateTrigger$: this.triggerHandler\n    });\n    this.templateManager.addTemplateRef(RxLetTemplateNames.next, this.nextTemplateRef);\n    this.templateManager.nextStrategy(this.strategyHandler.values$);\n  }\n\n}\n/** @nocollapse */\n\n\nLetDirective.ɵfac = function LetDirective_Factory(t) {\n  return new (t || LetDirective)(i0.ɵɵdirectiveInject(i1.RxStrategyProvider), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.TemplateRef), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i0.ErrorHandler));\n};\n/** @nocollapse */\n\n\nLetDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: LetDirective,\n  selectors: [[\"\", \"rxLet\", \"\"]],\n  inputs: {\n    rxLet: \"rxLet\",\n    strategy: [\"rxLetStrategy\", \"strategy\"],\n    complete: [\"rxLetComplete\", \"complete\"],\n    error: [\"rxLetError\", \"error\"],\n    suspense: [\"rxLetSuspense\", \"suspense\"],\n    templateTrigger: [\"rxLetTemplateTrg\", \"templateTrigger\"],\n    completeTrigger: [\"rxLetCompleteTrg\", \"completeTrigger\"],\n    errorTrigger: [\"rxLetErrorTrg\", \"errorTrigger\"],\n    suspenseTrigger: [\"rxLetSuspenseTrg\", \"suspenseTrigger\"],\n    nextTrigger: [\"rxLetNextTrg\", \"nextTrigger\"],\n    renderCallback: [\"rxLetRenderCallback\", \"renderCallback\"],\n    renderParent: [\"rxLetParent\", \"renderParent\"],\n    patchZone: [\"rxLetPatchZone\", \"patchZone\"]\n  },\n  outputs: {\n    rendered: \"rendered\"\n  },\n  features: [i0.ɵɵNgOnChangesFeature]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LetDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[rxLet]'\n    }]\n  }], function () {\n    return [{\n      type: i1.RxStrategyProvider\n    }, {\n      type: i0.ChangeDetectorRef\n    }, {\n      type: i0.NgZone\n    }, {\n      type: i0.TemplateRef\n    }, {\n      type: i0.ViewContainerRef\n    }, {\n      type: i0.ErrorHandler\n    }];\n  }, {\n    rxLet: [{\n      type: Input\n    }],\n    strategy: [{\n      type: Input,\n      args: ['rxLetStrategy']\n    }],\n    complete: [{\n      type: Input,\n      args: ['rxLetComplete']\n    }],\n    error: [{\n      type: Input,\n      args: ['rxLetError']\n    }],\n    suspense: [{\n      type: Input,\n      args: ['rxLetSuspense']\n    }],\n    templateTrigger: [{\n      type: Input,\n      args: ['rxLetTemplateTrg']\n    }],\n    completeTrigger: [{\n      type: Input,\n      args: ['rxLetCompleteTrg']\n    }],\n    errorTrigger: [{\n      type: Input,\n      args: ['rxLetErrorTrg']\n    }],\n    suspenseTrigger: [{\n      type: Input,\n      args: ['rxLetSuspenseTrg']\n    }],\n    nextTrigger: [{\n      type: Input,\n      args: ['rxLetNextTrg']\n    }],\n    renderCallback: [{\n      type: Input,\n      args: ['rxLetRenderCallback']\n    }],\n    renderParent: [{\n      type: Input,\n      args: ['rxLetParent']\n    }],\n    patchZone: [{\n      type: Input,\n      args: ['rxLetPatchZone']\n    }],\n    rendered: [{\n      type: Output\n    }]\n  });\n})();\n\nclass LetModule {}\n/** @nocollapse */\n\n\nLetModule.ɵfac = function LetModule_Factory(t) {\n  return new (t || LetModule)();\n};\n/** @nocollapse */\n\n\nLetModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: LetModule\n});\n/** @nocollapse */\n\nLetModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LetModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [LetDirective],\n      exports: [LetDirective]\n    }]\n  }], null, null);\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { LetDirective, LetModule };","map":{"version":3,"names":["i0","Directive","Input","Output","NgModule","coerceAllFactory","createTemplateNotifier","i1","RxBaseTemplateNames","createTemplateManager","ReplaySubject","Subscription","Subject","defer","merge","NEVER","map","filter","RxLetTemplateNames","Object","assign","next","LetDirective","constructor","strategyProvider","cdRef","ngZone","nextTemplateRef","viewContainerRef","errorHandler","renderParent","config","parent","patchZone","observablesHandler","strategyHandler","triggerHandler","subscription","rendered$","templateNotification$","values$","rendered","strategy","strategyName","renderCallback","callback","_renderObserver","ngTemplateContextGuard","dir","ctx","ngOnInit","_a","_b","_c","_d","add","templateManager","render","subscribe","n","templateTrigger","nextTrigger","pipe","suspenseTrigger","completeTrigger","errorTrigger","v","t","ngOnChanges","changes","_createTemplateManager","complete","addTemplateRef","suspense","withInitialSuspense","error","rxLet","ngOnDestroy","unsubscribe","templateSettings","customContext","renderSettings","defaultStrategyName","primaryStrategy","strategies","notificationToTemplateName","templateTrigger$","nextStrategy","ɵfac","RxStrategyProvider","ChangeDetectorRef","NgZone","TemplateRef","ViewContainerRef","ErrorHandler","ɵdir","type","args","selector","LetModule","ɵmod","ɵinj","declarations","exports"],"sources":["/home/bessam/Documents/Medisail/angular/angular interview/reactive-project-angular/node_modules/@rx-angular/template/fesm2015/template-let.js"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { Directive, Input, Output, NgModule } from '@angular/core';\nimport { coerceAllFactory } from '@rx-angular/cdk/coercing';\nimport { createTemplateNotifier } from '@rx-angular/cdk/notifications';\nimport * as i1 from '@rx-angular/cdk/render-strategies';\nimport { RxBaseTemplateNames, createTemplateManager } from '@rx-angular/cdk/template';\nimport { ReplaySubject, Subscription, Subject, defer, merge, NEVER } from 'rxjs';\nimport { map, filter } from 'rxjs/operators';\n\n/** @internal */\nconst RxLetTemplateNames = Object.assign(Object.assign({}, RxBaseTemplateNames), { next: 'nextTpl' });\n/**\n * @Directive LetDirective\n *\n * @description\n * In Angular there is one way to handle asynchronous values or streams in the template, the `async` pipe.\n * Even though the async pipe evaluates such values in the template, it is insufficient in many ways.\n * To name a few:\n * * it will only update the template when `NgZone` is also aware of the value change\n * * it leads to over rendering because it can only run global change detection\n * * it leads to too many subscriptions in the template\n * * it is cumbersome to work with values in the template\n *\n * read more about the LetDirective in the [official docs](https://www.rx-angular.io/docs/template/api/let-directive)\n *\n * **Conclusion - Structural directives**\n *\n * In contrast to global change detection, structural directives allow fine-grained control of change detection on a per directive basis.\n * The `LetDirective` comes with its own way to handle change detection in templates in a very efficient way.\n * However, the change detection behavior is configurable on a per directive or global basis.\n * This makes it possible to implement your own strategies, and also provides a migration path from large existing apps running with Angulars default change detection.\n *\n * This package helps to reduce code used to create composable action streams.\n * It mostly is used in combination with state management libs to handle user interaction and backend communication.\n *\n * ```html\n * <ng-container *rxLet=\"observableNumber$; let n\">\n *  ...\n * </ng-container>\n * ```\n *\n *\n * @docsCategory LetDirective\n * @docsPage LetDirective\n * @publicApi\n */\nclass LetDirective {\n    constructor(strategyProvider, cdRef, ngZone, nextTemplateRef, viewContainerRef, errorHandler) {\n        this.strategyProvider = strategyProvider;\n        this.cdRef = cdRef;\n        this.ngZone = ngZone;\n        this.nextTemplateRef = nextTemplateRef;\n        this.viewContainerRef = viewContainerRef;\n        this.errorHandler = errorHandler;\n        /**\n         * @description\n         *\n         * When local rendering strategies are used, we need to treat view and content queries in a\n         * special way.\n         * To make `*rxLet` in such situations, a certain mechanism is implemented to\n         * execute change detection on the parent (`parent`).\n         *\n         * This is required if your components state is dependent on its view or content children:\n         *\n         * - `@ViewChild`\n         * - `@ViewChildren`\n         * - `@ContentChild`\n         * - `@ContentChildren`\n         *\n         * Read more about this in the\n         * [official\n         * docs](https://www.rx-angular.io/docs/template/api/let-directive#local-strategies-and-view-content-queries-parent).\n         *\n         * @example\n         * \\@Component({\n         *   selector: 'app-root',\n         *   template: `\n         *    <app-list-component>\n         *      <app-list-item\n         *        *rxLet=\"\n         *          item$;\n         *          let item;\n         *          parent: true;\n         *        \"\n         *      >\n         *        <div>{{ item.name }}</div>\n         *      </app-list-item>\n         *    </app-list-component>\n         *   `\n         * })\n         * export class AppComponent {\n         *   item$ = itemService.getItem();\n         * }\n         *\n         * @param boolean\n         */\n        this.renderParent = this.strategyProvider.config.parent;\n        /**\n         * @description\n         * A flag to control whether *rxLet templates are created within `NgZone` or not.\n         * The default value is `true, `*rxLet` will create it's `EmbeddedViews` inside `NgZone`.\n         *\n         * Event listeners normally trigger zone. Especially high frequently events cause performance issues.\n         *\n         * Read more about this in the\n         * [official docs](https://www.rx-angular.io/docs/template/api/let-directive#working-with-event-listeners-patchzone).\n         *\n         * @example\n         * \\@Component({\n         *   selector: 'app-root',\n         *   template: `\n         *    <app-list-component>\n         *      <app-list-item\n         *        *rxLet=\"\n         *          item$;\n         *          let item;\n         *          patchZone: false;\n         *        \"\n         *      >\n         *        <div>{{ item.name }}</div>\n         *      </app-list-item>\n         *    </app-list-component>\n         *   `\n         * })\n         * export class AppComponent {\n         *   item$ = itemService.getItem();\n         * }\n         */\n        this.patchZone = this.strategyProvider.config.patchZone;\n        /** @internal */\n        this.observablesHandler = createTemplateNotifier();\n        /** @internal */\n        this.strategyHandler = coerceAllFactory(() => new ReplaySubject(1));\n        /** @internal */\n        this.triggerHandler = new ReplaySubject(1);\n        /** @internal */\n        this.subscription = new Subscription();\n        /** @internal */\n        this.rendered$ = new Subject();\n        /** @internal */\n        this.templateNotification$ = new Subject();\n        /** @internal */\n        this.values$ = this.observablesHandler.values$;\n        this.rendered = defer(() => this.rendered$);\n    }\n    /**\n     * @description\n     *\n     * You can change the used `RenderStrategy` by using the `strategy` input of the `*rxLet`. It accepts\n     * an `Observable<RxStrategyNames>` or [`RxStrategyNames`](https://github.com/rx-angular/rx-angular/blob/b0630f69017cc1871d093e976006066d5f2005b9/libs/cdk/render-strategies/src/lib/model.ts#L52).\n     *\n     * The default value for strategy is\n     * [`normal`](https://www.rx-angular.io/docs/template/cdk/render-strategies/strategies/concurrent-strategies).\n     *\n     * Read more about this in the\n     * [official docs](https://www.rx-angular.io/docs/template/api/let-directive#use-render-strategies-strategy).\n     *\n     * @example\n     *\n     * \\@Component({\n     *   selector: 'app-root',\n     *   template: `\n     *     <ng-container *rxLet=\"hero$; let hero; strategy: strategy\">\n     *       <app-hero [hero]=\"hero\"></app-hero>\n     *     </ng-container>\n     *\n     *     <ng-container *rxLet=\"hero$; let hero; strategy: strategy$\">\n     *       <app-hero [hero]=\"hero\"></app-hero>\n     *     </ng-container>\n     *   `\n     * })\n     * export class AppComponent {\n     *   strategy = 'low';\n     *   strategy$ = of('immediate');\n     * }\n     *\n     * @param { string | Observable<string> | undefined } strategyName\n     * @see {@link RxStrategyNames}\n     */\n    set strategy(strategyName) {\n        this.strategyHandler.next(strategyName);\n    }\n    /**\n     * @description\n     * A `Subject` which emits whenever *rxFor finished rendering a set changes to the view.\n     * This enables developers to perform actions when a list has finished rendering.\n     * The `renderCallback` is useful in situations where you rely on specific DOM properties like the `height` a\n     * table after all items got rendered.\n     * It is also possible to use the renderCallback in order to determine if a view should be visible or not. This\n     * way developers can hide a list as long as it has not finished rendering.\n     *\n     * The result of the `renderCallback` will contain the currently rendered set of items in the iterable.\n     *\n     * @example\n     * \\Component({\n     *   selector: 'app-root',\n     *   template: `\n     *   <app-list-component>\n     *     <app-list-item\n     *       *rxFor=\"\n     *         let item of items$;\n     *         trackBy: trackItem;\n     *         renderCallback: itemsRendered;\n     *       \">\n     *       <div>{{ item.name }}</div>\n     *     </app-list-item>\n     *   </app-list-component>\n     * `\n     * })\n     * export class AppComponent {\n     *   items$: Observable<Item[]> = itemService.getItems();\n     *   trackItem = (idx, item) => item.id;\n     *   // this emits whenever rxFor finished rendering changes\n     *   itemsRendered = new Subject<Item[]>();\n     *\n     *   constructor(elementRef: ElementRef<HTMLElement>) {\n     *     itemsRendered.subscribe(() => {\n     *       // items are rendered, we can now scroll\n     *       elementRef.scrollTo({bottom: 0});\n     *     })\n     *   }\n     * }\n     *\n     * @param {Subject<U>} renderCallback\n     */\n    set renderCallback(callback) {\n        this._renderObserver = callback;\n    }\n    /** @internal */\n    static ngTemplateContextGuard(dir, ctx) {\n        return true;\n    }\n    /** @internal */\n    ngOnInit() {\n        var _a, _b, _c, _d;\n        this.subscription.add(this.templateManager\n            .render(merge(this.values$, this.templateNotification$))\n            .subscribe((n) => {\n            var _a;\n            this.rendered$.next(n);\n            (_a = this._renderObserver) === null || _a === void 0 ? void 0 : _a.next(n);\n        }));\n        this.subscription.add(merge(this.templateTrigger || NEVER, ((_a = this.nextTrigger) === null || _a === void 0 ? void 0 : _a.pipe(map(() => \"next\" /* Next */))) || NEVER, ((_b = this.suspenseTrigger) === null || _b === void 0 ? void 0 : _b.pipe(map(() => \"suspense\" /* Suspense */))) ||\n            NEVER, ((_c = this.completeTrigger) === null || _c === void 0 ? void 0 : _c.pipe(map(() => \"complete\" /* Complete */))) ||\n            NEVER, ((_d = this.errorTrigger) === null || _d === void 0 ? void 0 : _d.pipe(map(() => \"error\" /* Error */))) || NEVER)\n            .pipe(filter((v) => !!v))\n            .subscribe((t) => this.triggerHandler.next(t)));\n    }\n    /** @internal */\n    ngOnChanges(changes) {\n        if (!this.templateManager) {\n            this._createTemplateManager();\n        }\n        if (changes.complete) {\n            this.templateManager.addTemplateRef(RxLetTemplateNames.complete, this.complete);\n        }\n        if (changes.suspense) {\n            this.templateManager.addTemplateRef(RxLetTemplateNames.suspense, this.suspense);\n            this.observablesHandler.withInitialSuspense(!!this.suspense);\n        }\n        if (changes.error) {\n            this.templateManager.addTemplateRef(RxLetTemplateNames.error, this.error);\n        }\n        if (changes.rxLet) {\n            this.observablesHandler.next(this.rxLet);\n        }\n    }\n    /** @internal */\n    ngOnDestroy() {\n        this.subscription.unsubscribe();\n    }\n    /** @internal */\n    _createTemplateManager() {\n        this.templateManager = createTemplateManager({\n            templateSettings: {\n                viewContainerRef: this.viewContainerRef,\n                customContext: (rxLet) => ({ rxLet }),\n            },\n            renderSettings: {\n                cdRef: this.cdRef,\n                parent: !!this.renderParent,\n                patchZone: this.patchZone ? this.ngZone : false,\n                defaultStrategyName: this.strategyProvider.primaryStrategy,\n                strategies: this.strategyProvider.strategies,\n                errorHandler: this.errorHandler,\n            },\n            notificationToTemplateName: {\n                [\"suspense\" /* Suspense */]: () => this.suspense ? RxLetTemplateNames.suspense : RxLetTemplateNames.next,\n                [\"next\" /* Next */]: () => RxLetTemplateNames.next,\n                [\"error\" /* Error */]: () => this.error ? RxLetTemplateNames.error : RxLetTemplateNames.next,\n                [\"complete\" /* Complete */]: () => this.complete ? RxLetTemplateNames.complete : RxLetTemplateNames.next,\n            },\n            templateTrigger$: this.triggerHandler,\n        });\n        this.templateManager.addTemplateRef(RxLetTemplateNames.next, this.nextTemplateRef);\n        this.templateManager.nextStrategy(this.strategyHandler.values$);\n    }\n}\n/** @nocollapse */ LetDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.16\", ngImport: i0, type: LetDirective, deps: [{ token: i1.RxStrategyProvider }, { token: i0.ChangeDetectorRef }, { token: i0.NgZone }, { token: i0.TemplateRef }, { token: i0.ViewContainerRef }, { token: i0.ErrorHandler }], target: i0.ɵɵFactoryTarget.Directive });\n/** @nocollapse */ LetDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"12.2.16\", type: LetDirective, selector: \"[rxLet]\", inputs: { rxLet: \"rxLet\", strategy: [\"rxLetStrategy\", \"strategy\"], complete: [\"rxLetComplete\", \"complete\"], error: [\"rxLetError\", \"error\"], suspense: [\"rxLetSuspense\", \"suspense\"], templateTrigger: [\"rxLetTemplateTrg\", \"templateTrigger\"], completeTrigger: [\"rxLetCompleteTrg\", \"completeTrigger\"], errorTrigger: [\"rxLetErrorTrg\", \"errorTrigger\"], suspenseTrigger: [\"rxLetSuspenseTrg\", \"suspenseTrigger\"], nextTrigger: [\"rxLetNextTrg\", \"nextTrigger\"], renderCallback: [\"rxLetRenderCallback\", \"renderCallback\"], renderParent: [\"rxLetParent\", \"renderParent\"], patchZone: [\"rxLetPatchZone\", \"patchZone\"] }, outputs: { rendered: \"rendered\" }, usesOnChanges: true, ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.16\", ngImport: i0, type: LetDirective, decorators: [{\n            type: Directive,\n            args: [{ selector: '[rxLet]' }]\n        }], ctorParameters: function () { return [{ type: i1.RxStrategyProvider }, { type: i0.ChangeDetectorRef }, { type: i0.NgZone }, { type: i0.TemplateRef }, { type: i0.ViewContainerRef }, { type: i0.ErrorHandler }]; }, propDecorators: { rxLet: [{\n                type: Input\n            }], strategy: [{\n                type: Input,\n                args: ['rxLetStrategy']\n            }], complete: [{\n                type: Input,\n                args: ['rxLetComplete']\n            }], error: [{\n                type: Input,\n                args: ['rxLetError']\n            }], suspense: [{\n                type: Input,\n                args: ['rxLetSuspense']\n            }], templateTrigger: [{\n                type: Input,\n                args: ['rxLetTemplateTrg']\n            }], completeTrigger: [{\n                type: Input,\n                args: ['rxLetCompleteTrg']\n            }], errorTrigger: [{\n                type: Input,\n                args: ['rxLetErrorTrg']\n            }], suspenseTrigger: [{\n                type: Input,\n                args: ['rxLetSuspenseTrg']\n            }], nextTrigger: [{\n                type: Input,\n                args: ['rxLetNextTrg']\n            }], renderCallback: [{\n                type: Input,\n                args: ['rxLetRenderCallback']\n            }], renderParent: [{\n                type: Input,\n                args: ['rxLetParent']\n            }], patchZone: [{\n                type: Input,\n                args: ['rxLetPatchZone']\n            }], rendered: [{\n                type: Output\n            }] } });\n\nclass LetModule {\n}\n/** @nocollapse */ LetModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.16\", ngImport: i0, type: LetModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\n/** @nocollapse */ LetModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"12.2.16\", ngImport: i0, type: LetModule, declarations: [LetDirective], exports: [LetDirective] });\n/** @nocollapse */ LetModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"12.2.16\", ngImport: i0, type: LetModule });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.16\", ngImport: i0, type: LetModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    declarations: [LetDirective],\n                    exports: [LetDirective],\n                }]\n        }] });\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { LetDirective, LetModule };\n"],"mappings":"AAAA,OAAO,KAAKA,EAAZ,MAAoB,eAApB;AACA,SAASC,SAAT,EAAoBC,KAApB,EAA2BC,MAA3B,EAAmCC,QAAnC,QAAmD,eAAnD;AACA,SAASC,gBAAT,QAAiC,0BAAjC;AACA,SAASC,sBAAT,QAAuC,+BAAvC;AACA,OAAO,KAAKC,EAAZ,MAAoB,mCAApB;AACA,SAASC,mBAAT,EAA8BC,qBAA9B,QAA2D,0BAA3D;AACA,SAASC,aAAT,EAAwBC,YAAxB,EAAsCC,OAAtC,EAA+CC,KAA/C,EAAsDC,KAAtD,EAA6DC,KAA7D,QAA0E,MAA1E;AACA,SAASC,GAAT,EAAcC,MAAd,QAA4B,gBAA5B;AAEA;;AACA,MAAMC,kBAAkB,GAAGC,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBZ,mBAAlB,CAAd,EAAsD;EAAEa,IAAI,EAAE;AAAR,CAAtD,CAA3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,YAAN,CAAmB;EACfC,WAAW,CAACC,gBAAD,EAAmBC,KAAnB,EAA0BC,MAA1B,EAAkCC,eAAlC,EAAmDC,gBAAnD,EAAqEC,YAArE,EAAmF;IAC1F,KAAKL,gBAAL,GAAwBA,gBAAxB;IACA,KAAKC,KAAL,GAAaA,KAAb;IACA,KAAKC,MAAL,GAAcA,MAAd;IACA,KAAKC,eAAL,GAAuBA,eAAvB;IACA,KAAKC,gBAAL,GAAwBA,gBAAxB;IACA,KAAKC,YAAL,GAAoBA,YAApB;IACA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IACQ,KAAKC,YAAL,GAAoB,KAAKN,gBAAL,CAAsBO,MAAtB,CAA6BC,MAAjD;IACA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IACQ,KAAKC,SAAL,GAAiB,KAAKT,gBAAL,CAAsBO,MAAtB,CAA6BE,SAA9C;IACA;;IACA,KAAKC,kBAAL,GAA0B5B,sBAAsB,EAAhD;IACA;;IACA,KAAK6B,eAAL,GAAuB9B,gBAAgB,CAAC,MAAM,IAAIK,aAAJ,CAAkB,CAAlB,CAAP,CAAvC;IACA;;IACA,KAAK0B,cAAL,GAAsB,IAAI1B,aAAJ,CAAkB,CAAlB,CAAtB;IACA;;IACA,KAAK2B,YAAL,GAAoB,IAAI1B,YAAJ,EAApB;IACA;;IACA,KAAK2B,SAAL,GAAiB,IAAI1B,OAAJ,EAAjB;IACA;;IACA,KAAK2B,qBAAL,GAA6B,IAAI3B,OAAJ,EAA7B;IACA;;IACA,KAAK4B,OAAL,GAAe,KAAKN,kBAAL,CAAwBM,OAAvC;IACA,KAAKC,QAAL,GAAgB5B,KAAK,CAAC,MAAM,KAAKyB,SAAZ,CAArB;EACH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACgB,IAARI,QAAQ,CAACC,YAAD,EAAe;IACvB,KAAKR,eAAL,CAAqBd,IAArB,CAA0BsB,YAA1B;EACH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACsB,IAAdC,cAAc,CAACC,QA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"},"metadata":{},"sourceType":"module"}