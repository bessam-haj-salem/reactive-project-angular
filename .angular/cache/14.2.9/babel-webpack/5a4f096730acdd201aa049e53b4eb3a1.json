{"ast":null,"code":"import { Subject, NEVER, ReplaySubject, isObservable, Observable, from } from 'rxjs';\nimport { mergeAll, share, materialize, tap, map, startWith, distinctUntilChanged, switchMap } from 'rxjs/operators';\nimport { coerceAllFactory } from '@rx-angular/cdk/coercing';\n\nfunction toRxErrorNotification(error, value) {\n  return {\n    value,\n    kind: \"error\"\n    /* Error */\n    ,\n    hasValue: !!value || false,\n    complete: false,\n    error: error || true\n  };\n}\n\nfunction toRxSuspenseNotification(value) {\n  return {\n    value,\n    kind: \"suspense\"\n    /* Suspense */\n    ,\n    hasValue: !!value || false,\n    complete: false,\n    error: false\n  };\n}\n\nfunction toRxCompleteNotification(value) {\n  return {\n    value,\n    kind: \"complete\"\n    /* Complete */\n    ,\n    hasValue: !!value || false,\n    complete: true,\n    error: false\n  };\n}\n/**\n * @internal\n *\n * A factory function returning an object to handle the process of switching templates by Notification channel.\n * You can next a Observable of `RxNotification` multiple times and merge them into the Observable exposed under `trigger$`\n *\n */\n\n\nfunction templateTriggerHandling() {\n  const hotFlattened = coerceAllFactory(() => new Subject(), mergeAll());\n  return {\n    next(templateName) {\n      hotFlattened.next(templateName);\n    },\n\n    trigger$: hotFlattened.values$.pipe(share())\n  };\n}\n\nfunction rxMaterialize() {\n  return o$ => o$.pipe(materialize(), tap(({\n    kind,\n    error\n  }) => {\n    // As we dont want to just swallow errors we log them here\n    if (kind === 'E') {\n      console.error(error);\n    }\n  }), map(({\n    value,\n    error,\n    kind,\n    hasValue\n  }) => {\n    const rxNotificationKind = notificationKindToRxNotificationKind(kind);\n    return {\n      value,\n      hasValue,\n      error,\n      kind: rxNotificationKind,\n      complete: rxNotificationKind === \"complete\"\n      /* Complete */\n\n    };\n  }));\n}\n/**\n * @internal\n *\n * @description\n * This function is here to turn RxJS notification kind values into RxNotification kind names.\n * The main reason for the naming is the RxNotification kind values map directly to the default\n * template names (`suspense`, `next`, `error` `complete`) in the directives of the template package\n */\n\n\nfunction notificationKindToRxNotificationKind(kind) {\n  switch (kind) {\n    case 'C':\n      return \"complete\"\n      /* Complete */\n      ;\n\n    case 'E':\n      return \"error\"\n      /* Error */\n      ;\n\n    case 'N':\n    default:\n      return \"next\"\n      /* Next */\n      ;\n  }\n}\n/**\n * @description\n * Sends value and an initial `undefined` as value With a NEVER.\n * This is needed to render the suspense template and avoid completing (and render the complete template).\n * @param value\n */\n\n\nconst emitAndDontComplete = value => NEVER.pipe(startWith(value));\n/**\n * This helper is responsible for turning a stream of materialized notifications\n * (next error, complete as object in the next stream) into an enriched version with an additional suspense\n * notification type.\n *\n * If a notification enters and is of type next we store tne value of `notification.next` as last value emitted.\n * This value is important in the template to show an e.g. error and also have access to the last emitted value of\n * next.\n * The value can be very useful in error or complete messages or to display the old value overlays by a loading spinner\n * in case of the suspense state.\n *\n * If a notification of kind `next` enters and its value is undefined we turn it into a suspense notification\n * If a notification of kind `error`, `complete`, `suspense` enters we take the last value from of a next notification\n * and assign it as new value to the notification\n */\n\n\nconst handleSuspenseAndLastValueInNotifications = () => {\n  // Used to store the last value per handleSuspenseAndLastValueInNotifications call\n  let latestNextValue; // returns a projection function with a lastValue cache\n\n  return notification => {\n    // if it is the notification is of type next we take its value\n    // otherwise we keep the existing last value\n    if (notification.kind === \"next\"\n    /* Next */\n    ) {\n      latestNextValue = notification.value;\n    } // If a next notification enters with a value of undefined we turn it into a suspense notification\n\n\n    if (notification.kind === \"next\"\n    /* Next */\n    && notification.value === undefined) {\n      return toRxSuspenseNotification(undefined);\n    } // If a Notification of type error, complete or suspense enters we assign the latest last value to them.\n    // This is needed to access the old value in case of error or complete.\n    // Next notifications will pass as they are.\n\n\n    if (notification.kind === \"error\"\n    /* Error */\n    || notification.kind === \"complete\"\n    /* Complete */\n    || notification.kind === \"suspense\"\n    /* Suspense */\n    ) {\n      notification.value = latestNextValue;\n    }\n\n    return notification;\n  };\n};\n/**\n * @internal\n *\n * @description\n * This factory function returns an object that can be driven imperatively over a `next` method.\n * Internally it prepares the incoming values for rendering by turning them into \"template notifications\",\n * an extended `ObservableNotification` object used to determine the respective template for values, errors, completing\n *   or suspense states.\n *\n * Internally it handles different edge cases for initial emits. This helps to have or template creation lazy.\n * Also it maps any Observable to RxNotifications. These notifications are bound to the view later and handle the\n *   display of the default template as well as the suspense, error, complete templates.\n */\n\n\nfunction createTemplateNotifier() {\n  // A Subject driven from the outside, it can contain Observables, static values null and undefined on purpose of from unassigned properties\n  const observablesSubject = new ReplaySubject(1);\n  let emittedValueOnce = false;\n  const values$ = observablesSubject.pipe(distinctUntilChanged(), // handle static values inc null assignment and new Observable or Promises\n  map(observable$ => {\n    if (isObservableInput(observable$)) {\n      return skipSuspenseIfHasValue(observable$);\n    } else if (!emittedValueOnce && observable$ === undefined) {\n      return NEVER;\n    }\n\n    return emitAndDontComplete(observable$);\n  }), switchMap(o => {\n    return o.pipe(tap(() => emittedValueOnce = true), distinctUntilChanged(), rxMaterialize(), map(handleSuspenseAndLastValueInNotifications()));\n  }));\n  return {\n    next(observable) {\n      observablesSubject.next(observable);\n    },\n\n    withInitialSuspense(withInitialSuspense) {\n      emittedValueOnce = emittedValueOnce || withInitialSuspense;\n    },\n\n    values$\n  };\n  /**\n   * @description\n   * returns an observable that starts with an undefined value in case the input\n   * observable$ does not emit a value immediately.\n   * This is needed in order to skip the suspense template when we already know\n   * there will be a next template rendered afterwards\n   * @param observable$\n   */\n\n  function skipSuspenseIfHasValue(observable$) {\n    return new Observable(subscriber => {\n      let startWithUndefined = true;\n      const inner = from(observable$).subscribe({\n        next: v => {\n          startWithUndefined = false;\n          subscriber.next(v);\n        },\n        error: e => {\n          startWithUndefined = false;\n          subscriber.error(e);\n        },\n        complete: () => subscriber.complete()\n      });\n\n      if (emittedValueOnce && startWithUndefined) {\n        subscriber.next(undefined);\n      }\n\n      return () => {\n        inner.unsubscribe();\n      };\n    });\n  }\n}\n\nfunction isObservableInput(input) {\n  var _a;\n\n  return typeof ((_a = input) === null || _a === void 0 ? void 0 : _a.then) === 'function' || isObservable(input);\n}\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { createTemplateNotifier, rxMaterialize, templateTriggerHandling, toRxCompleteNotification, toRxErrorNotification, toRxSuspenseNotification };","map":{"version":3,"names":["Subject","NEVER","ReplaySubject","isObservable","Observable","from","mergeAll","share","materialize","tap","map","startWith","distinctUntilChanged","switchMap","coerceAllFactory","toRxErrorNotification","error","value","kind","hasValue","complete","toRxSuspenseNotification","toRxCompleteNotification","templateTriggerHandling","hotFlattened","next","templateName","trigger$","values$","pipe","rxMaterialize","o$","console","rxNotificationKind","notificationKindToRxNotificationKind","emitAndDontComplete","handleSuspenseAndLastValueInNotifications","latestNextValue","notification","undefined","createTemplateNotifier","observablesSubject","emittedValueOnce","observable$","isObservableInput","skipSuspenseIfHasValue","o","observable","withInitialSuspense","subscriber","startWithUndefined","inner","subscribe","v","e","unsubscribe","input","_a","then"],"sources":["/home/bessam/Documents/Medisail/angular/angular interview/reactive-project-angular/node_modules/@rx-angular/cdk/fesm2015/cdk-notifications.js"],"sourcesContent":["import { Subject, NEVER, ReplaySubject, isObservable, Observable, from } from 'rxjs';\nimport { mergeAll, share, materialize, tap, map, startWith, distinctUntilChanged, switchMap } from 'rxjs/operators';\nimport { coerceAllFactory } from '@rx-angular/cdk/coercing';\n\nfunction toRxErrorNotification(error, value) {\n    return {\n        value,\n        kind: \"error\" /* Error */,\n        hasValue: !!value || false,\n        complete: false,\n        error: error || true,\n    };\n}\nfunction toRxSuspenseNotification(value) {\n    return {\n        value,\n        kind: \"suspense\" /* Suspense */,\n        hasValue: !!value || false,\n        complete: false,\n        error: false,\n    };\n}\nfunction toRxCompleteNotification(value) {\n    return {\n        value,\n        kind: \"complete\" /* Complete */,\n        hasValue: !!value || false,\n        complete: true,\n        error: false,\n    };\n}\n\n/**\n * @internal\n *\n * A factory function returning an object to handle the process of switching templates by Notification channel.\n * You can next a Observable of `RxNotification` multiple times and merge them into the Observable exposed under `trigger$`\n *\n */\nfunction templateTriggerHandling() {\n    const hotFlattened = coerceAllFactory(() => new Subject(), mergeAll());\n    return {\n        next(templateName) {\n            hotFlattened.next(templateName);\n        },\n        trigger$: hotFlattened.values$.pipe(share()),\n    };\n}\n\nfunction rxMaterialize() {\n    return (o$) => o$.pipe(materialize(), tap(({ kind, error }) => {\n        // As we dont want to just swallow errors we log them here\n        if (kind === 'E') {\n            console.error(error);\n        }\n    }), map(({ value, error, kind, hasValue }) => {\n        const rxNotificationKind = notificationKindToRxNotificationKind(kind);\n        return {\n            value,\n            hasValue,\n            error,\n            kind: rxNotificationKind,\n            complete: rxNotificationKind === \"complete\" /* Complete */,\n        };\n    }));\n}\n/**\n * @internal\n *\n * @description\n * This function is here to turn RxJS notification kind values into RxNotification kind names.\n * The main reason for the naming is the RxNotification kind values map directly to the default\n * template names (`suspense`, `next`, `error` `complete`) in the directives of the template package\n */\nfunction notificationKindToRxNotificationKind(kind) {\n    switch (kind) {\n        case 'C':\n            return \"complete\" /* Complete */;\n        case 'E':\n            return \"error\" /* Error */;\n        case 'N':\n        default:\n            return \"next\" /* Next */;\n    }\n}\n\n/**\n * @description\n * Sends value and an initial `undefined` as value With a NEVER.\n * This is needed to render the suspense template and avoid completing (and render the complete template).\n * @param value\n */\nconst emitAndDontComplete = (value) => NEVER.pipe(startWith(value));\n/**\n * This helper is responsible for turning a stream of materialized notifications\n * (next error, complete as object in the next stream) into an enriched version with an additional suspense\n * notification type.\n *\n * If a notification enters and is of type next we store tne value of `notification.next` as last value emitted.\n * This value is important in the template to show an e.g. error and also have access to the last emitted value of\n * next.\n * The value can be very useful in error or complete messages or to display the old value overlays by a loading spinner\n * in case of the suspense state.\n *\n * If a notification of kind `next` enters and its value is undefined we turn it into a suspense notification\n * If a notification of kind `error`, `complete`, `suspense` enters we take the last value from of a next notification\n * and assign it as new value to the notification\n */\nconst handleSuspenseAndLastValueInNotifications = () => {\n    // Used to store the last value per handleSuspenseAndLastValueInNotifications call\n    let latestNextValue;\n    // returns a projection function with a lastValue cache\n    return (notification) => {\n        // if it is the notification is of type next we take its value\n        // otherwise we keep the existing last value\n        if (notification.kind === \"next\" /* Next */) {\n            latestNextValue = notification.value;\n        }\n        // If a next notification enters with a value of undefined we turn it into a suspense notification\n        if (notification.kind === \"next\" /* Next */ &&\n            notification.value === undefined) {\n            return toRxSuspenseNotification(undefined);\n        }\n        // If a Notification of type error, complete or suspense enters we assign the latest last value to them.\n        // This is needed to access the old value in case of error or complete.\n        // Next notifications will pass as they are.\n        if (notification.kind === \"error\" /* Error */ ||\n            notification.kind === \"complete\" /* Complete */ ||\n            notification.kind === \"suspense\" /* Suspense */) {\n            notification.value = latestNextValue;\n        }\n        return notification;\n    };\n};\n/**\n * @internal\n *\n * @description\n * This factory function returns an object that can be driven imperatively over a `next` method.\n * Internally it prepares the incoming values for rendering by turning them into \"template notifications\",\n * an extended `ObservableNotification` object used to determine the respective template for values, errors, completing\n *   or suspense states.\n *\n * Internally it handles different edge cases for initial emits. This helps to have or template creation lazy.\n * Also it maps any Observable to RxNotifications. These notifications are bound to the view later and handle the\n *   display of the default template as well as the suspense, error, complete templates.\n */\nfunction createTemplateNotifier() {\n    // A Subject driven from the outside, it can contain Observables, static values null and undefined on purpose of from unassigned properties\n    const observablesSubject = new ReplaySubject(1);\n    let emittedValueOnce = false;\n    const values$ = observablesSubject.pipe(distinctUntilChanged(), \n    // handle static values inc null assignment and new Observable or Promises\n    map((observable$) => {\n        if (isObservableInput(observable$)) {\n            return skipSuspenseIfHasValue(observable$);\n        }\n        else if (!emittedValueOnce && observable$ === undefined) {\n            return NEVER;\n        }\n        return emitAndDontComplete(observable$);\n    }), switchMap((o) => {\n        return o.pipe(tap(() => (emittedValueOnce = true)), distinctUntilChanged(), rxMaterialize(), map(handleSuspenseAndLastValueInNotifications()));\n    }));\n    return {\n        next(observable) {\n            observablesSubject.next(observable);\n        },\n        withInitialSuspense(withInitialSuspense) {\n            emittedValueOnce = emittedValueOnce || withInitialSuspense;\n        },\n        values$,\n    };\n    /**\n     * @description\n     * returns an observable that starts with an undefined value in case the input\n     * observable$ does not emit a value immediately.\n     * This is needed in order to skip the suspense template when we already know\n     * there will be a next template rendered afterwards\n     * @param observable$\n     */\n    function skipSuspenseIfHasValue(observable$) {\n        return new Observable((subscriber) => {\n            let startWithUndefined = true;\n            const inner = from(observable$).subscribe({\n                next: (v) => {\n                    startWithUndefined = false;\n                    subscriber.next(v);\n                },\n                error: (e) => {\n                    startWithUndefined = false;\n                    subscriber.error(e);\n                },\n                complete: () => subscriber.complete(),\n            });\n            if (emittedValueOnce && startWithUndefined) {\n                subscriber.next(undefined);\n            }\n            return () => {\n                inner.unsubscribe();\n            };\n        });\n    }\n}\nfunction isObservableInput(input) {\n    var _a;\n    return (typeof ((_a = input) === null || _a === void 0 ? void 0 : _a.then) === 'function' || isObservable(input));\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { createTemplateNotifier, rxMaterialize, templateTriggerHandling, toRxCompleteNotification, toRxErrorNotification, toRxSuspenseNotification };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}