{"ast":null,"code":"import { isObservable, of, Subject } from 'rxjs';\nimport { map, switchAll, distinctUntilChanged } from 'rxjs/operators';\n/**\n * This Observable factory creates an Observable out of a static value or ObservableInput.\n *\n * @param o - the value to coerce\n */\n\nfunction coerceObservable(o) {\n  return isObservable(o) ? o : of(o);\n}\n/**\n * This operator maps an Observable out of a static value or ObservableInput.\n *\n */\n\n\nfunction coerceObservableWith() {\n  return o$ => map(coerceObservable)(o$);\n}\n/**\n * This Observable factory creates an Observable out of a static value or ObservableInput.\n * It forwards only distinct values from distinct incoming Observables or values.\n * This comes in handy in any environment where you handle processing of incoming dynamic values and their state.\n *\n * Optionally you can pass a flatten strategy to get find grained control of the flattening process. E.g. mergeAll, switchAll\n *\n * @param o$ - The Observable to coerce and map to a Observable with distinct values\n * @param flattenOperator - determines the flattening strategy e.g. mergeAll, concatAll, exhaust, switchAll. default is switchAll\n */\n\n\nfunction coerceDistinctObservable(o$, flattenOperator) {\n  flattenOperator = flattenOperator || switchAll();\n  return coerceObservable(o$).pipe(distinctUntilChanged(), flattenOperator, distinctUntilChanged());\n}\n/**\n * This operator takes an Observable of values ot Observables aof values and\n * It forwards only distinct values from distinct incoming Observables or values.\n * This comes in handy in any environment where you handle processing of incoming dynamic values and their state.\n *\n * Optionally you can pass a flatten strategy to get find grained control of the flattening process. E.g. mergeAll, switchAll\n *\n * @param flattenOperator - determines the flattening strategy e.g. mergeAll, concatAll, exhaust, switchAll. default is switchAll\n *\n */\n\n\nfunction coerceDistinctWith(flattenOperator) {\n  flattenOperator = flattenOperator || switchAll();\n  return o$ => o$.pipe(coerceObservableWith(), distinctUntilChanged(), flattenOperator, distinctUntilChanged());\n}\n/**\n * @internal\n *\n * A factory function returning an object to handle the process of merging Observable next notifications into one\n *   Observable. This API takes away the clumsy handling of static values and Observable, reduces the number of\n *   emissions by:\n * - only merging distinct Observables\n * - only emit distingt values of the merged result\n *\n * You can next a Observable of `U` multiple times and merge them into the Observable exposed under one optimized\n *   `values$`\n *\n */\n\n\nfunction coerceAllFactory(subjectFactory, flattenOperator) {\n  const observablesSubject = subjectFactory ? subjectFactory() : new Subject();\n  flattenOperator = flattenOperator || switchAll();\n  const values$ = observablesSubject.pipe(coerceDistinctWith(flattenOperator));\n  return {\n    next(observable) {\n      observablesSubject.next(observable);\n    },\n\n    values$\n  };\n}\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { coerceAllFactory, coerceDistinctObservable, coerceDistinctWith, coerceObservable, coerceObservableWith };","map":{"version":3,"names":["isObservable","of","Subject","map","switchAll","distinctUntilChanged","coerceObservable","o","coerceObservableWith","o$","coerceDistinctObservable","flattenOperator","pipe","coerceDistinctWith","coerceAllFactory","subjectFactory","observablesSubject","values$","next","observable"],"sources":["/home/bessam/Documents/Medisail/angular/angular interview/reactive-project-angular/node_modules/@rx-angular/cdk/fesm2015/cdk-coercing.js"],"sourcesContent":["import { isObservable, of, Subject } from 'rxjs';\nimport { map, switchAll, distinctUntilChanged } from 'rxjs/operators';\n\n/**\n * This Observable factory creates an Observable out of a static value or ObservableInput.\n *\n * @param o - the value to coerce\n */\nfunction coerceObservable(o) {\n    return isObservable(o) ? o : of(o);\n}\n\n/**\n * This operator maps an Observable out of a static value or ObservableInput.\n *\n */\nfunction coerceObservableWith() {\n    return (o$) => map(coerceObservable)(o$);\n}\n\n/**\n * This Observable factory creates an Observable out of a static value or ObservableInput.\n * It forwards only distinct values from distinct incoming Observables or values.\n * This comes in handy in any environment where you handle processing of incoming dynamic values and their state.\n *\n * Optionally you can pass a flatten strategy to get find grained control of the flattening process. E.g. mergeAll, switchAll\n *\n * @param o$ - The Observable to coerce and map to a Observable with distinct values\n * @param flattenOperator - determines the flattening strategy e.g. mergeAll, concatAll, exhaust, switchAll. default is switchAll\n */\nfunction coerceDistinctObservable(o$, flattenOperator) {\n    flattenOperator = flattenOperator || switchAll();\n    return coerceObservable(o$).pipe(distinctUntilChanged(), flattenOperator, distinctUntilChanged());\n}\n\n/**\n * This operator takes an Observable of values ot Observables aof values and\n * It forwards only distinct values from distinct incoming Observables or values.\n * This comes in handy in any environment where you handle processing of incoming dynamic values and their state.\n *\n * Optionally you can pass a flatten strategy to get find grained control of the flattening process. E.g. mergeAll, switchAll\n *\n * @param flattenOperator - determines the flattening strategy e.g. mergeAll, concatAll, exhaust, switchAll. default is switchAll\n *\n */\nfunction coerceDistinctWith(flattenOperator) {\n    flattenOperator = flattenOperator || switchAll();\n    return (o$) => o$.pipe(coerceObservableWith(), distinctUntilChanged(), flattenOperator, distinctUntilChanged());\n}\n\n/**\n * @internal\n *\n * A factory function returning an object to handle the process of merging Observable next notifications into one\n *   Observable. This API takes away the clumsy handling of static values and Observable, reduces the number of\n *   emissions by:\n * - only merging distinct Observables\n * - only emit distingt values of the merged result\n *\n * You can next a Observable of `U` multiple times and merge them into the Observable exposed under one optimized\n *   `values$`\n *\n */\nfunction coerceAllFactory(subjectFactory, flattenOperator) {\n    const observablesSubject = subjectFactory ? subjectFactory() : new Subject();\n    flattenOperator = flattenOperator || switchAll();\n    const values$ = observablesSubject.pipe(coerceDistinctWith(flattenOperator));\n    return {\n        next(observable) {\n            observablesSubject.next(observable);\n        },\n        values$,\n    };\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { coerceAllFactory, coerceDistinctObservable, coerceDistinctWith, coerceObservable, coerceObservableWith };\n"],"mappings":"AAAA,SAASA,YAAT,EAAuBC,EAAvB,EAA2BC,OAA3B,QAA0C,MAA1C;AACA,SAASC,GAAT,EAAcC,SAAd,EAAyBC,oBAAzB,QAAqD,gBAArD;AAEA;AACA;AACA;AACA;AACA;;AACA,SAASC,gBAAT,CAA0BC,CAA1B,EAA6B;EACzB,OAAOP,YAAY,CAACO,CAAD,CAAZ,GAAkBA,CAAlB,GAAsBN,EAAE,CAACM,CAAD,CAA/B;AACH;AAED;AACA;AACA;AACA;;;AACA,SAASC,oBAAT,GAAgC;EAC5B,OAAQC,EAAD,IAAQN,GAAG,CAACG,gBAAD,CAAH,CAAsBG,EAAtB,CAAf;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,wBAAT,CAAkCD,EAAlC,EAAsCE,eAAtC,EAAuD;EACnDA,eAAe,GAAGA,eAAe,IAAIP,SAAS,EAA9C;EACA,OAAOE,gBAAgB,CAACG,EAAD,CAAhB,CAAqBG,IAArB,CAA0BP,oBAAoB,EAA9C,EAAkDM,eAAlD,EAAmEN,oBAAoB,EAAvF,CAAP;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASQ,kBAAT,CAA4BF,eAA5B,EAA6C;EACzCA,eAAe,GAAGA,eAAe,IAAIP,SAAS,EAA9C;EACA,OAAQK,EAAD,IAAQA,EAAE,CAACG,IAAH,CAAQJ,oBAAoB,EAA5B,EAAgCH,oBAAoB,EAApD,EAAwDM,eAAxD,EAAyEN,oBAAoB,EAA7F,CAAf;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASS,gBAAT,CAA0BC,cAA1B,EAA0CJ,eAA1C,EAA2D;EACvD,MAAMK,kBAAkB,GAAGD,cAAc,GAAGA,cAAc,EAAjB,GAAsB,IAAIb,OAAJ,EAA/D;EACAS,eAAe,GAAGA,eAAe,IAAIP,SAAS,EAA9C;EACA,MAAMa,OAAO,GAAGD,kBAAkB,CAACJ,IAAnB,CAAwBC,kBAAkB,CAACF,eAAD,CAA1C,CAAhB;EACA,OAAO;IACHO,IAAI,CAACC,UAAD,EAAa;MACbH,kBAAkB,CAACE,IAAnB,CAAwBC,UAAxB;IACH,CAHE;;IAIHF;EAJG,CAAP;AAMH;AAED;AACA;AACA;;;AAEA,SAASH,gBAAT,EAA2BJ,wBAA3B,EAAqDG,kBAArD,EAAyEP,gBAAzE,EAA2FE,oBAA3F"},"metadata":{},"sourceType":"module"}