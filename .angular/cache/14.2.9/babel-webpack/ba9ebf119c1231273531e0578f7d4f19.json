{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Directive, Input, NgModule } from '@angular/core';\nimport { Subscription, BehaviorSubject } from 'rxjs';\nimport { getZoneUnPatchedApi } from '@rx-angular/cdk/internals/core';\nimport { focusEvents, mouseEvents, wheelEvents, inputEvents, keyboardEvents, touchEvents } from '@rx-angular/cdk/zone-configurations';\nconst zonePatchedEvents = [...focusEvents, ...mouseEvents, ...wheelEvents, ...inputEvents, ...keyboardEvents, ...touchEvents];\n/**\n *\n * @description\n *\n * This function takes an elem and event and re-applies the listeners from the passed event to the\n * passed element with the zone un-patched version of it.\n *\n * @param elem {HTMLElement} - The elem to re-apply the listeners to.\n * @param event {string} - The name of the event from which to re-apply the listeners.\n *\n * @returns void\n */\n\nfunction unpatchEventListener(element, event) {\n  // `EventTarget` is patched only in the browser environment, thus\n  // running this code on the server-side will throw an exception:\n  // `TypeError: element.eventListeners is not a function`.\n  if (typeof element.eventListeners !== 'function') {\n    return;\n  }\n\n  const eventListeners = element.eventListeners(event); // Return if no event listeners are present\n\n  if (!Array.isArray(eventListeners) || eventListeners.length === 0) {\n    return;\n  }\n\n  const addEventListener = getZoneUnPatchedApi(element, 'addEventListener').bind(element);\n  eventListeners.forEach(listener => {\n    // Remove and reapply listeners with patched API\n    // @TODO use (elem as any).removeAllListeners?(eventName?: string): void;\n    element.removeEventListener(event, listener); // Reapply listeners with un-patched API\n\n    addEventListener(event, listener);\n  });\n}\n/* eslint-disable @angular-eslint/directive-selector */\n\n/**\n * @Directive UnpatchEventsDirective\n *\n * @description\n *\n * The `unpatch` directive helps in partially migrating to zone-less apps as well as getting rid\n * of unnecessary renderings through zones `addEventListener` patches.\n * It can be used on any element you apply event bindings.\n *\n * The current way of binding events to the DOM is to use output bindings:\n *  ```html\n * <button (click)=\"doStuff($event)\">click me</button>\n * ```\n *\n * The problem is that every event registered over `()` syntax, e.g. `(click)`\n * marks the component and all its ancestors as dirty and re-renders the whole component tree.\n * This is because zone.js patches the native browser API and whenever one of the patched APIs is used it re-renders.\n *\n * So even if your button is not related to a change that needs a re-render the app will re-render completely.\n * This leads to bad performance. This is especially helpful if you work with frequently fired events like 'mousemove'\n *\n * `unpatch` directive solves that problem.\n *\n * Included Features:\n *  - by default un-patch all registered listeners of the host it is applied on\n *  - un-patch only a specified set of registered event listeners\n *  - works zone independent (it directly checks the widow for patched APIs and un-patches them without the use of `runOutsideZone` which brings more performance)\n *  - Not interfering with any logic executed by the registered callback\n *\n * @usageNotes\n *\n * The `unpatch` directive can be used like shown here:\n * ```html\n * <button [unpatch] (click)=\"triggerSomeMethod($event)\">click me</button>\n * <button [unpatch]=\"['mousemove']\" (mousemove)=\"doStuff2($event)\" (click)=\"doStuff($event)\">click me</button>\n * ```\n *\n * @publicApi\n */\n\n/**\n * @todo: add prefix [rxUnpatch]\n */\n\n\nclass UnpatchDirective {\n  constructor(host) {\n    this.host = host;\n    this.subscription = new Subscription();\n    this.events$ = new BehaviorSubject(zonePatchedEvents);\n  }\n\n  ngOnChanges({\n    events\n  }) {\n    if (events && Array.isArray(this.events)) {\n      this.events$.next(this.events);\n    }\n  }\n\n  ngAfterViewInit() {\n    this.subscription = this.events$.subscribe(events => {\n      this.reapplyUnPatchedEventListeners(events);\n    });\n  }\n\n  ngOnDestroy() {\n    this.subscription.unsubscribe();\n  }\n\n  reapplyUnPatchedEventListeners(events) {\n    for (const event of events) {\n      unpatchEventListener(this.host.nativeElement, event);\n    }\n  }\n\n}\n/** @nocollapse */\n\n\nUnpatchDirective.ɵfac = function UnpatchDirective_Factory(t) {\n  return new (t || UnpatchDirective)(i0.ɵɵdirectiveInject(i0.ElementRef));\n};\n/** @nocollapse */\n\n\nUnpatchDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: UnpatchDirective,\n  selectors: [[\"\", \"unpatch\", \"\"]],\n  inputs: {\n    events: [\"unpatch\", \"events\"]\n  },\n  features: [i0.ɵɵNgOnChangesFeature]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(UnpatchDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[unpatch]'\n    }]\n  }], function () {\n    return [{\n      type: i0.ElementRef\n    }];\n  }, {\n    events: [{\n      type: Input,\n      args: ['unpatch']\n    }]\n  });\n})();\n\nclass UnpatchModule {}\n/** @nocollapse */\n\n\nUnpatchModule.ɵfac = function UnpatchModule_Factory(t) {\n  return new (t || UnpatchModule)();\n};\n/** @nocollapse */\n\n\nUnpatchModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: UnpatchModule\n});\n/** @nocollapse */\n\nUnpatchModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(UnpatchModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [UnpatchDirective],\n      exports: [UnpatchDirective]\n    }]\n  }], null, null);\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { UnpatchDirective, UnpatchModule };","map":{"version":3,"names":["i0","Directive","Input","NgModule","Subscription","BehaviorSubject","getZoneUnPatchedApi","focusEvents","mouseEvents","wheelEvents","inputEvents","keyboardEvents","touchEvents","zonePatchedEvents","unpatchEventListener","element","event","eventListeners","Array","isArray","length","addEventListener","bind","forEach","listener","removeEventListener","UnpatchDirective","constructor","host","subscription","events$","ngOnChanges","events","next","ngAfterViewInit","subscribe","reapplyUnPatchedEventListeners","ngOnDestroy","unsubscribe","nativeElement","ɵfac","ElementRef","ɵdir","type","args","selector","UnpatchModule","ɵmod","ɵinj","declarations","exports"],"sources":["/home/bessam/Documents/Medisail/angular/angular interview/reactive-project-angular/node_modules/@rx-angular/template/fesm2015/template-unpatch.js"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { Directive, Input, NgModule } from '@angular/core';\nimport { Subscription, BehaviorSubject } from 'rxjs';\nimport { getZoneUnPatchedApi } from '@rx-angular/cdk/internals/core';\nimport { focusEvents, mouseEvents, wheelEvents, inputEvents, keyboardEvents, touchEvents } from '@rx-angular/cdk/zone-configurations';\n\nconst zonePatchedEvents = [\n    ...focusEvents,\n    ...mouseEvents,\n    ...wheelEvents,\n    ...inputEvents,\n    ...keyboardEvents,\n    ...touchEvents,\n];\n/**\n *\n * @description\n *\n * This function takes an elem and event and re-applies the listeners from the passed event to the\n * passed element with the zone un-patched version of it.\n *\n * @param elem {HTMLElement} - The elem to re-apply the listeners to.\n * @param event {string} - The name of the event from which to re-apply the listeners.\n *\n * @returns void\n */\nfunction unpatchEventListener(element, event) {\n    // `EventTarget` is patched only in the browser environment, thus\n    // running this code on the server-side will throw an exception:\n    // `TypeError: element.eventListeners is not a function`.\n    if (typeof element.eventListeners !== 'function') {\n        return;\n    }\n    const eventListeners = element.eventListeners(event);\n    // Return if no event listeners are present\n    if (!Array.isArray(eventListeners) || eventListeners.length === 0) {\n        return;\n    }\n    const addEventListener = getZoneUnPatchedApi(element, 'addEventListener').bind(element);\n    eventListeners.forEach((listener) => {\n        // Remove and reapply listeners with patched API\n        // @TODO use (elem as any).removeAllListeners?(eventName?: string): void;\n        element.removeEventListener(event, listener);\n        // Reapply listeners with un-patched API\n        addEventListener(event, listener);\n    });\n}\n/* eslint-disable @angular-eslint/directive-selector */\n/**\n * @Directive UnpatchEventsDirective\n *\n * @description\n *\n * The `unpatch` directive helps in partially migrating to zone-less apps as well as getting rid\n * of unnecessary renderings through zones `addEventListener` patches.\n * It can be used on any element you apply event bindings.\n *\n * The current way of binding events to the DOM is to use output bindings:\n *  ```html\n * <button (click)=\"doStuff($event)\">click me</button>\n * ```\n *\n * The problem is that every event registered over `()` syntax, e.g. `(click)`\n * marks the component and all its ancestors as dirty and re-renders the whole component tree.\n * This is because zone.js patches the native browser API and whenever one of the patched APIs is used it re-renders.\n *\n * So even if your button is not related to a change that needs a re-render the app will re-render completely.\n * This leads to bad performance. This is especially helpful if you work with frequently fired events like 'mousemove'\n *\n * `unpatch` directive solves that problem.\n *\n * Included Features:\n *  - by default un-patch all registered listeners of the host it is applied on\n *  - un-patch only a specified set of registered event listeners\n *  - works zone independent (it directly checks the widow for patched APIs and un-patches them without the use of `runOutsideZone` which brings more performance)\n *  - Not interfering with any logic executed by the registered callback\n *\n * @usageNotes\n *\n * The `unpatch` directive can be used like shown here:\n * ```html\n * <button [unpatch] (click)=\"triggerSomeMethod($event)\">click me</button>\n * <button [unpatch]=\"['mousemove']\" (mousemove)=\"doStuff2($event)\" (click)=\"doStuff($event)\">click me</button>\n * ```\n *\n * @publicApi\n */\n/**\n * @todo: add prefix [rxUnpatch]\n */\nclass UnpatchDirective {\n    constructor(host) {\n        this.host = host;\n        this.subscription = new Subscription();\n        this.events$ = new BehaviorSubject(zonePatchedEvents);\n    }\n    ngOnChanges({ events }) {\n        if (events && Array.isArray(this.events)) {\n            this.events$.next(this.events);\n        }\n    }\n    ngAfterViewInit() {\n        this.subscription = this.events$.subscribe((events) => {\n            this.reapplyUnPatchedEventListeners(events);\n        });\n    }\n    ngOnDestroy() {\n        this.subscription.unsubscribe();\n    }\n    reapplyUnPatchedEventListeners(events) {\n        for (const event of events) {\n            unpatchEventListener(this.host.nativeElement, event);\n        }\n    }\n}\n/** @nocollapse */ UnpatchDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.16\", ngImport: i0, type: UnpatchDirective, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });\n/** @nocollapse */ UnpatchDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"12.2.16\", type: UnpatchDirective, selector: \"[unpatch]\", inputs: { events: [\"unpatch\", \"events\"] }, usesOnChanges: true, ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.16\", ngImport: i0, type: UnpatchDirective, decorators: [{\n            type: Directive,\n            args: [{ selector: '[unpatch]' }]\n        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; }, propDecorators: { events: [{\n                type: Input,\n                args: ['unpatch']\n            }] } });\n\nclass UnpatchModule {\n}\n/** @nocollapse */ UnpatchModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.16\", ngImport: i0, type: UnpatchModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\n/** @nocollapse */ UnpatchModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"12.2.16\", ngImport: i0, type: UnpatchModule, declarations: [UnpatchDirective], exports: [UnpatchDirective] });\n/** @nocollapse */ UnpatchModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"12.2.16\", ngImport: i0, type: UnpatchModule });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.16\", ngImport: i0, type: UnpatchModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    declarations: [UnpatchDirective],\n                    exports: [UnpatchDirective],\n                }]\n        }] });\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { UnpatchDirective, UnpatchModule };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}