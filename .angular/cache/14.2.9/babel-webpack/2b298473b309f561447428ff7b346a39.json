{"ast":null,"code":"import { onStrategy, strategyHandling } from '@rx-angular/cdk/render-strategies';\nimport { of, concat, EMPTY, merge, combineLatest, ReplaySubject, BehaviorSubject } from 'rxjs';\nimport { switchMap, ignoreElements, tap, map, withLatestFrom, catchError, distinctUntilChanged, pluck } from 'rxjs/operators';\n/**\n * @internal\n * creates an embeddedViewRef\n *\n * @param viewContainerRef\n * @param templateRef\n * @param context\n * @param index\n * @return EmbeddedViewRef<C>\n */\n\nfunction createEmbeddedView(viewContainerRef, templateRef, context, index = 0) {\n  const view = viewContainerRef.createEmbeddedView(templateRef, context, index);\n  view.detectChanges();\n  return view;\n}\n/**\n * @internal\n *\n * A factory function returning an object to handle `TemplateRef`'s.\n * You can add and get a `TemplateRef`.\n *\n */\n\n\nfunction templateHandling(viewContainerRef) {\n  const templateCache = new Map();\n\n  const get = name => {\n    return templateCache.get(name);\n  };\n\n  return {\n    add(name, templateRef) {\n      assertTemplate(name, templateRef);\n\n      if (!templateCache.has(name)) {\n        templateCache.set(name, templateRef);\n      } else {\n        throw new Error('Updating an already existing Template is not supported at the moment.');\n      }\n    },\n\n    get,\n    createEmbeddedView: (name, context) => createEmbeddedView(viewContainerRef, get(name), context)\n  }; //\n\n  function assertTemplate(property, templateRef) {\n    const isTemplateRefOrNull = !!(!templateRef || templateRef.createEmbeddedView);\n\n    if (!isTemplateRefOrNull) {\n      throw new Error(`${property} must be a TemplateRef, but received something else.`);\n    }\n\n    return isTemplateRefOrNull;\n  }\n}\n/**\n * @internal\n *\n * A side effect operator similar to `tap` but with a static internal logic.\n * It calls detect changes on the 'VirtualParent' and the injectingViewCdRef.\n *\n * @param injectingViewCdRef\n * @param strategy\n * @param notifyNeeded\n * @param ngZone\n */\n\n\nfunction notifyAllParentsIfNeeded(injectingViewCdRef, strategy, notifyNeeded, ngZone) {\n  return o$ => o$.pipe(switchMap(v => {\n    const notifyParent = notifyNeeded();\n\n    if (!notifyParent) {\n      return of(v);\n    }\n\n    return concat(of(v), onStrategy(injectingViewCdRef, strategy, (_v, work, options) => {\n      /*console.log(\n       'notifyAllParentsIfNeeded injectingView',\n       (injectingViewCdRef as any).context\n       );*/\n      work(injectingViewCdRef, options.scope);\n    }, {\n      scope: injectingViewCdRef.context || injectingViewCdRef,\n      ngZone\n    }).pipe(ignoreElements()));\n  }));\n}\n\nvar RxBaseTemplateNames;\n\n(function (RxBaseTemplateNames) {\n  RxBaseTemplateNames[\"error\"] = \"errorTpl\";\n  RxBaseTemplateNames[\"complete\"] = \"completeTpl\";\n  RxBaseTemplateNames[\"suspense\"] = \"suspenseTpl\";\n})(RxBaseTemplateNames || (RxBaseTemplateNames = {}));\n/** @internal **/\n\n\nfunction isRxRenderError(e) {\n  return e != null && Array.isArray(e) && e.length === 2 && e[0] instanceof Error;\n}\n/** @internal **/\n\n\nfunction createErrorHandler(_handler) {\n  const _handleError = _handler ? e => _handler.handleError(e) : console.error;\n\n  return {\n    handleError: error => {\n      if (isRxRenderError(error)) {\n        _handleError(error[0]);\n\n        console.error('additionalErrorContext', error[1]);\n      } else {\n        _handleError(error);\n      }\n    }\n  };\n}\n/** @internal **/\n\n\nfunction toRenderError(e, context) {\n  return [e, context];\n}\n/**\n * @internal\n *\n * A factory function that returns a map of projections to turn a notification of a Observable (next, error, complete)\n *\n * @param customNextContext - projection function to provide custom properties as well as override existing\n */\n\n\nfunction notificationKindToViewContext(customNextContext) {\n  // @TODO rethink overrides\n  return {\n    suspense: notification => {\n      const $implicit = notification.value;\n      return Object.assign({\n        $implicit,\n        suspense: true,\n        error: false,\n        complete: false\n      }, customNextContext($implicit));\n    },\n    next: notification => {\n      const $implicit = notification.value;\n      return Object.assign({\n        $implicit,\n        suspense: false,\n        error: false,\n        complete: false\n      }, customNextContext($implicit));\n    },\n    error: notification => {\n      const $implicit = notification.value;\n      return Object.assign({\n        $implicit,\n        complete: false,\n        error: notification.error || true,\n        suspense: false\n      }, customNextContext($implicit));\n    },\n    complete: notification => {\n      const $implicit = notification.value;\n      return Object.assign({\n        $implicit,\n        error: false,\n        complete: true,\n        suspense: false\n      }, customNextContext($implicit));\n    }\n  };\n}\n\nfunction createTemplateManager(config) {\n  const {\n    renderSettings,\n    notificationToTemplateName,\n    templateSettings\n  } = config;\n  const {\n    defaultStrategyName,\n    strategies,\n    cdRef: injectingViewCdRef,\n    patchZone,\n    parent\n  } = renderSettings;\n  const errorHandler = createErrorHandler(renderSettings.errorHandler);\n  const ngZone = patchZone ? patchZone : undefined;\n  let activeTemplate;\n  const strategyHandling$ = strategyHandling(defaultStrategyName, strategies);\n  const templates = templateHandling(templateSettings.viewContainerRef);\n  const viewContainerRef = templateSettings.viewContainerRef;\n  const triggerHandling = config.templateTrigger$ || EMPTY;\n  const getContext = notificationKindToViewContext(templateSettings.customContext || (() => ({})));\n  return {\n    addTemplateRef: (name, templateRef) => {\n      templates.add(name, templateRef);\n    },\n    nextStrategy: strategyHandling$.next,\n\n    render(values$) {\n      let trg;\n      let notification = {\n        value: undefined,\n        complete: false,\n        error: false,\n        kind: \"suspense\"\n        /* Suspense */\n        ,\n        hasValue: false\n      };\n      return merge(values$.pipe(tap(n => notification = n)), triggerHandling.pipe(tap(trigger => trg = trigger))).pipe(map(() => {\n        const contextKind = trg || notification.kind;\n        trg = undefined;\n        const value = notification.value;\n        const templateName = notificationToTemplateName[contextKind](value, templates);\n        const template = templates.get(templateName);\n        return {\n          template,\n          templateName,\n          notification,\n          contextKind\n        };\n      }), withLatestFrom(strategyHandling$.strategy$), // Cancel old renders\n      switchMap(([{\n        template,\n        templateName,\n        notification,\n        contextKind\n      }, strategy]) => {\n        const isNewTemplate = activeTemplate !== templateName || !template;\n        const notifyParent = isNewTemplate && parent;\n        return onStrategy(notification.value, strategy, (v, work, options) => {\n          const context = getContext[contextKind](notification);\n\n          if (isNewTemplate) {\n            // template has changed (undefined => next; suspense => next; ...)\n            // handle remove & insert\n            // remove current view if there is any\n            if (viewContainerRef.length > 0) {\n              // patch removal if needed\n              viewContainerRef.clear();\n            } // create new view if any\n\n\n            if (template) {\n              // createEmbeddedView is already patched, no need for workFactory\n              templates.createEmbeddedView(templateName, context);\n            }\n          } else if (template) {\n            // template didn't change, update it\n            // handle update\n            const view = viewContainerRef.get(0);\n            Object.keys(context).forEach(k => {\n              view.context[k] = context[k];\n            }); // update view context, patch if needed\n\n            work(view, options.scope, notification);\n          }\n\n          activeTemplate = templateName;\n        }, {\n          ngZone\n        } // we don't need to specify any scope here. The template manager is the only one\n        // who will call `viewRef#detectChanges` on any of the templates it manages.\n        // whenever a new value comes in, any pre-scheduled work of this taskManager will\n        // be nooped before a new work will be scheduled. This happens because of the implementation\n        // of `StrategyCredential#behavior`\n        ).pipe(notifyAllParentsIfNeeded(injectingViewCdRef, strategy, () => notifyParent, ngZone), catchError(e => {\n          errorHandler.handleError(e);\n          return of(e);\n        }));\n      }));\n    }\n\n  };\n}\n/**\n * @internal\n *\n * Factory that returns a `ListTemplateManager` for the passed params.\n *\n * @param templateSettings\n */\n\n\nfunction getTemplateHandler(templateSettings) {\n  const {\n    viewContainerRef,\n    initialTemplateRef,\n    createViewContext,\n    updateViewContext\n  } = templateSettings;\n  return {\n    updateUnchangedContext,\n    insertView,\n    moveView,\n    removeView,\n    getListChanges,\n    updateView\n  }; // =====\n\n  function updateUnchangedContext(item, index, count) {\n    const view = viewContainerRef.get(index);\n    updateViewContext(item, view, {\n      count,\n      index\n    });\n    view.detectChanges();\n  }\n\n  function moveView(oldIndex, item, index, count) {\n    const oldView = viewContainerRef.get(oldIndex);\n    const view = viewContainerRef.move(oldView, index);\n    updateViewContext(item, view, {\n      count,\n      index\n    });\n    view.detectChanges();\n  }\n\n  function updateView(item, index, count) {\n    const view = viewContainerRef.get(index);\n    updateViewContext(item, view, {\n      count,\n      index\n    });\n    view.detectChanges();\n  }\n\n  function removeView(index) {\n    return viewContainerRef.remove(index);\n  }\n\n  function insertView(item, index, count) {\n    createEmbeddedView(viewContainerRef, initialTemplateRef, createViewContext(item, {\n      count,\n      index\n    }), index);\n  }\n}\n/**\n * @internal\n *\n * @param changes\n * @param items\n */\n\n\nfunction getListChanges(changes, items) {\n  const changedIdxs = new Set();\n  const changesArr = [];\n  let notifyParent = false;\n  changes.forEachOperation((record, adjustedPreviousIndex, currentIndex) => {\n    const item = record.item;\n\n    if (record.previousIndex == null) {\n      // insert\n      changesArr.push(getInsertChange(item, currentIndex === null ? undefined : currentIndex));\n      changedIdxs.add(item);\n      notifyParent = true;\n    } else if (currentIndex == null) {\n      // remove\n      changesArr.push(getRemoveChange(item, adjustedPreviousIndex === null ? undefined : adjustedPreviousIndex));\n      notifyParent = true;\n    } else if (adjustedPreviousIndex !== null) {\n      // move\n      changesArr.push(getMoveChange(item, currentIndex, adjustedPreviousIndex));\n      changedIdxs.add(item);\n      notifyParent = true;\n    }\n  });\n  changes.forEachIdentityChange(record => {\n    const item = record.item;\n\n    if (!changedIdxs.has(item)) {\n      changesArr.push(getUpdateChange(item, record.currentIndex));\n      changedIdxs.add(item);\n    }\n  });\n  items.forEach((item, index) => {\n    if (!changedIdxs.has(item)) {\n      changesArr.push(getUnchangedChange(item, index));\n    }\n  });\n  return [changesArr, notifyParent]; // ==========\n\n  function getMoveChange(item, currentIndex, adjustedPreviousIndex) {\n    return [2\n    /* move */\n    , [item, currentIndex, adjustedPreviousIndex]];\n  }\n\n  function getUpdateChange(item, currentIndex) {\n    return [3\n    /* update */\n    , [item, currentIndex]];\n  }\n\n  function getUnchangedChange(item, index) {\n    return [4\n    /* context */\n    , [item, index]];\n  }\n\n  function getInsertChange(item, currentIndex) {\n    return [0\n    /* insert */\n    , [item, currentIndex === null ? undefined : currentIndex]];\n  }\n\n  function getRemoveChange(item, adjustedPreviousIndex) {\n    return [1\n    /* remove */\n    , [item, adjustedPreviousIndex === null ? undefined : adjustedPreviousIndex]];\n  }\n}\n\nfunction createListTemplateManager(config) {\n  const {\n    templateSettings,\n    renderSettings,\n    trackBy,\n    iterableDiffers\n  } = config;\n  const {\n    defaultStrategyName,\n    strategies,\n    cdRef: injectingViewCdRef,\n    patchZone,\n    parent\n  } = renderSettings;\n  const errorHandler = createErrorHandler(renderSettings.errorHandler);\n  const ngZone = patchZone ? patchZone : undefined;\n  const strategyHandling$ = strategyHandling(defaultStrategyName, strategies);\n\n  let _differ;\n\n  function getDiffer(values) {\n    if (_differ) {\n      return _differ;\n    }\n\n    return values ? _differ = iterableDiffers.find(values).create(trackBy) : null;\n  } //               type,  context\n\n  /* TODO (regarding createView): this is currently not in use. for the list-manager this would mean to provide\n   functions for not only create. developers than should have to provide create, move, remove,... the whole thing.\n   i don't know if this is the right decision for a first RC */\n\n\n  const listViewHandler = getTemplateHandler(Object.assign(Object.assign({}, templateSettings), {\n    initialTemplateRef: templateSettings.templateRef\n  }));\n  const viewContainerRef = templateSettings.viewContainerRef;\n  let notifyParent = false;\n  let changesArr;\n  let partiallyFinished = false;\n  return {\n    nextStrategy(nextConfig) {\n      strategyHandling$.next(nextConfig);\n    },\n\n    render(values$) {\n      return values$.pipe(render());\n    }\n\n  };\n\n  function handleError() {\n    return o$ => o$.pipe(catchError(err => {\n      partiallyFinished = false;\n      errorHandler.handleError(err);\n      return of(null);\n    }));\n  }\n\n  function render() {\n    return o$ => combineLatest([o$, strategyHandling$.strategy$.pipe(distinctUntilChanged())]).pipe(map(([iterable, strategy]) => {\n      const differ = getDiffer(iterable);\n      let changes;\n\n      if (differ) {\n        if (partiallyFinished) {\n          const currentIterable = [];\n\n          for (let i = 0, ilen = viewContainerRef.length; i < ilen; i++) {\n            const viewRef = viewContainerRef.get(i);\n            currentIterable[i] = viewRef.context.$implicit;\n          }\n\n          differ.diff(currentIterable);\n        }\n\n        changes = differ.diff(iterable);\n      }\n\n      return {\n        changes,\n        iterable,\n        strategy\n      };\n    }), // Cancel old renders\n    switchMap(({\n      changes,\n      iterable,\n      strategy\n    }) => {\n      if (!changes) {\n        return of([]);\n      }\n\n      const values = iterable || []; // TODO: we might want to treat other iterables in a more performant way than Array.from()\n\n      const items = Array.isArray(values) ? values : Array.from(iterable);\n      const listChanges = listViewHandler.getListChanges(changes, items);\n      changesArr = listChanges[0];\n      const insertedOrRemoved = listChanges[1];\n      const applyChanges$ = getObservablesFromChangesArray(changesArr, strategy, items.length);\n      partiallyFinished = true;\n      notifyParent = insertedOrRemoved && parent;\n      return combineLatest(applyChanges$.length > 0 ? applyChanges$ : [of(null)]).pipe(tap(() => partiallyFinished = false), notifyAllParentsIfNeeded(injectingViewCdRef, strategy, () => notifyParent, ngZone), handleError(), map(() => iterable));\n    }), handleError());\n  }\n  /**\n   * @internal\n   *\n   * returns an array of streams which process all of the view updates needed to reflect the latest diff to the\n   * viewContainer.\n   * I\n   *\n   * @param changes\n   * @param strategy\n   * @param count\n   */\n\n\n  function getObservablesFromChangesArray(changes, strategy, count) {\n    return changes.length > 0 ? changes.map(change => {\n      const payload = change[1];\n      return onStrategy(change[0], strategy, type => {\n        switch (type) {\n          case 0\n          /* insert */\n          :\n            listViewHandler.insertView(payload[0], payload[1], count);\n            break;\n\n          case 2\n          /* move */\n          :\n            listViewHandler.moveView(payload[2], payload[0], payload[1], count);\n            break;\n\n          case 1\n          /* remove */\n          :\n            listViewHandler.removeView(payload[1]);\n            break;\n\n          case 3\n          /* update */\n          :\n            listViewHandler.updateView(payload[0], payload[1], count);\n            break;\n\n          case 4\n          /* context */\n          :\n            listViewHandler.updateUnchangedContext(payload[0], payload[1], count);\n            break;\n        }\n      }, {\n        ngZone\n      });\n    }) : [of(null)];\n  }\n}\n\nconst computeFirst = ({\n  count,\n  index\n}) => index === 0;\n\nconst computeLast = ({\n  count,\n  index\n}) => index === count - 1;\n\nconst computeEven = ({\n  count,\n  index\n}) => index % 2 === 0;\n\nclass RxDefaultListViewContext {\n  constructor(item, customProps) {\n    this._item = new ReplaySubject(1);\n    this.item$ = this._item.asObservable();\n    this._context$ = new BehaviorSubject({\n      index: -1,\n      count: -1\n    });\n\n    this.select = props => {\n      return this.item$.pipe(pluck(...props));\n    };\n\n    this.$implicit = item;\n\n    if (customProps) {\n      this.updateContext(customProps);\n    }\n  }\n\n  set $implicit($implicit) {\n    this._$implicit = $implicit;\n\n    this._item.next($implicit);\n  }\n\n  get $implicit() {\n    return this._$implicit;\n  }\n\n  get $complete() {\n    return this._$complete;\n  }\n\n  get $error() {\n    return this._$error;\n  }\n\n  get $suspense() {\n    return this._$suspense;\n  }\n\n  get index() {\n    return this._context$.getValue().index;\n  }\n\n  get count() {\n    return this._context$.getValue().count;\n  }\n\n  get first() {\n    return computeFirst(this._context$.getValue());\n  }\n\n  get last() {\n    return computeLast(this._context$.getValue());\n  }\n\n  get even() {\n    return computeEven(this._context$.getValue());\n  }\n\n  get odd() {\n    return !this.even;\n  }\n\n  get index$() {\n    return this._context$.pipe(pluck('index'), distinctUntilChanged());\n  }\n\n  get count$() {\n    return this._context$.pipe(pluck('count'), distinctUntilChanged());\n  }\n\n  get first$() {\n    return this._context$.pipe(map(computeFirst), distinctUntilChanged());\n  }\n\n  get last$() {\n    return this._context$.pipe(map(computeLast), distinctUntilChanged());\n  }\n\n  get even$() {\n    return this._context$.pipe(map(computeEven), distinctUntilChanged());\n  }\n\n  get odd$() {\n    return this.even$.pipe(map(even => !even));\n  }\n\n  updateContext(newProps) {\n    this._context$.next(Object.assign(Object.assign({}, this._context$.getValue()), newProps));\n  }\n\n}\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { RxBaseTemplateNames, RxDefaultListViewContext, createListTemplateManager, createTemplateManager, templateHandling };","map":{"version":3,"names":["onStrategy","strategyHandling","of","concat","EMPTY","merge","combineLatest","ReplaySubject","BehaviorSubject","switchMap","ignoreElements","tap","map","withLatestFrom","catchError","distinctUntilChanged","pluck","createEmbeddedView","viewContainerRef","templateRef","context","index","view","detectChanges","templateHandling","templateCache","Map","get","name","add","assertTemplate","has","set","Error","property","isTemplateRefOrNull","notifyAllParentsIfNeeded","injectingViewCdRef","strategy","notifyNeeded","ngZone","o$","pipe","v","notifyParent","_v","work","options","scope","RxBaseTemplateNames","isRxRenderError","e","Array","isArray","length","createErrorHandler","_handler","_handleError","handleError","console","error","toRenderError","notificationKindToViewContext","customNextContext","suspense","notification","$implicit","value","Object","assign","complete","next","createTemplateManager","config","renderSettings","notificationToTemplateName","templateSettings","defaultStrategyName","strategies","cdRef","patchZone","parent","errorHandler","undefined","activeTemplate","strategyHandling$","templates","triggerHandling","templateTrigger$","getContext","customContext","addTemplateRef","nextStrategy","render","values$","trg","kind","hasValue","n","trigger","contextKind","templateName","template","strategy$","isNewTemplate","clear","keys","forEach","k","getTemplateHandler","initialTemplateRef","createViewContext","updateViewContext","updateUnchangedContext","insertView","moveView","removeView","getListChanges","updateView","item","count","oldIndex","oldView","move","remove","changes","items","changedIdxs","Set","changesArr","forEachOperation","record","adjustedPreviousIndex","currentIndex","previousIndex","push","getInsertChange","getRemoveChange","getMoveChange","forEachIdentityChange","getUpdateChange","getUnchangedChange","createListTemplateManager","trackBy","iterableDiffers","_differ","getDiffer","values","find","create","listViewHandler","partiallyFinished","nextConfig","err","iterable","differ","currentIterable","i","ilen","viewRef","diff","from","listChanges","insertedOrRemoved","applyChanges$","getObservablesFromChangesArray","change","payload","type","computeFirst","computeLast","computeEven","RxDefaultListViewContext","constructor","customProps","_item","item$","asObservable","_context$","select","props","updateContext","_$implicit","$complete","_$complete","$error","_$error","$suspense","_$suspense","getValue","first","last","even","odd","index$","count$","first$","last$","even$","odd$","newProps"],"sources":["/home/bessam/Documents/Medisail/angular/angular interview/reactive-project-angular/node_modules/@rx-angular/cdk/fesm2015/cdk-template.js"],"sourcesContent":["import { onStrategy, strategyHandling } from '@rx-angular/cdk/render-strategies';\nimport { of, concat, EMPTY, merge, combineLatest, ReplaySubject, BehaviorSubject } from 'rxjs';\nimport { switchMap, ignoreElements, tap, map, withLatestFrom, catchError, distinctUntilChanged, pluck } from 'rxjs/operators';\n\n/**\n * @internal\n * creates an embeddedViewRef\n *\n * @param viewContainerRef\n * @param templateRef\n * @param context\n * @param index\n * @return EmbeddedViewRef<C>\n */\nfunction createEmbeddedView(viewContainerRef, templateRef, context, index = 0) {\n    const view = viewContainerRef.createEmbeddedView(templateRef, context, index);\n    view.detectChanges();\n    return view;\n}\n/**\n * @internal\n *\n * A factory function returning an object to handle `TemplateRef`'s.\n * You can add and get a `TemplateRef`.\n *\n */\nfunction templateHandling(viewContainerRef) {\n    const templateCache = new Map();\n    const get = (name) => {\n        return templateCache.get(name);\n    };\n    return {\n        add(name, templateRef) {\n            assertTemplate(name, templateRef);\n            if (!templateCache.has(name)) {\n                templateCache.set(name, templateRef);\n            }\n            else {\n                throw new Error('Updating an already existing Template is not supported at the moment.');\n            }\n        },\n        get,\n        createEmbeddedView: (name, context) => createEmbeddedView(viewContainerRef, get(name), context),\n    };\n    //\n    function assertTemplate(property, templateRef) {\n        const isTemplateRefOrNull = !!(!templateRef || templateRef.createEmbeddedView);\n        if (!isTemplateRefOrNull) {\n            throw new Error(`${property} must be a TemplateRef, but received something else.`);\n        }\n        return isTemplateRefOrNull;\n    }\n}\n/**\n * @internal\n *\n * A side effect operator similar to `tap` but with a static internal logic.\n * It calls detect changes on the 'VirtualParent' and the injectingViewCdRef.\n *\n * @param injectingViewCdRef\n * @param strategy\n * @param notifyNeeded\n * @param ngZone\n */\nfunction notifyAllParentsIfNeeded(injectingViewCdRef, strategy, notifyNeeded, ngZone) {\n    return (o$) => o$.pipe(switchMap((v) => {\n        const notifyParent = notifyNeeded();\n        if (!notifyParent) {\n            return of(v);\n        }\n        return concat(of(v), onStrategy(injectingViewCdRef, strategy, (_v, work, options) => {\n            /*console.log(\n             'notifyAllParentsIfNeeded injectingView',\n             (injectingViewCdRef as any).context\n             );*/\n            work(injectingViewCdRef, options.scope);\n        }, {\n            scope: injectingViewCdRef.context || injectingViewCdRef,\n            ngZone,\n        }).pipe(ignoreElements()));\n    }));\n}\n\nvar RxBaseTemplateNames;\n(function (RxBaseTemplateNames) {\n    RxBaseTemplateNames[\"error\"] = \"errorTpl\";\n    RxBaseTemplateNames[\"complete\"] = \"completeTpl\";\n    RxBaseTemplateNames[\"suspense\"] = \"suspenseTpl\";\n})(RxBaseTemplateNames || (RxBaseTemplateNames = {}));\n\n/** @internal **/\nfunction isRxRenderError(e) {\n    return (e != null && Array.isArray(e) && e.length === 2 && e[0] instanceof Error);\n}\n/** @internal **/\nfunction createErrorHandler(_handler) {\n    const _handleError = _handler\n        ? (e) => _handler.handleError(e)\n        : console.error;\n    return {\n        handleError: (error) => {\n            if (isRxRenderError(error)) {\n                _handleError(error[0]);\n                console.error('additionalErrorContext', error[1]);\n            }\n            else {\n                _handleError(error);\n            }\n        },\n    };\n}\n/** @internal **/\nfunction toRenderError(e, context) {\n    return [e, context];\n}\n\n/**\n * @internal\n *\n * A factory function that returns a map of projections to turn a notification of a Observable (next, error, complete)\n *\n * @param customNextContext - projection function to provide custom properties as well as override existing\n */\nfunction notificationKindToViewContext(customNextContext) {\n    // @TODO rethink overrides\n    return {\n        suspense: (notification) => {\n            const $implicit = notification.value;\n            return Object.assign({ $implicit, suspense: true, error: false, complete: false }, customNextContext($implicit));\n        },\n        next: (notification) => {\n            const $implicit = notification.value;\n            return Object.assign({ $implicit, suspense: false, error: false, complete: false }, customNextContext($implicit));\n        },\n        error: (notification) => {\n            const $implicit = notification.value;\n            return Object.assign({ $implicit, complete: false, error: notification.error || true, suspense: false }, customNextContext($implicit));\n        },\n        complete: (notification) => {\n            const $implicit = notification.value;\n            return Object.assign({ $implicit, error: false, complete: true, suspense: false }, customNextContext($implicit));\n        },\n    };\n}\nfunction createTemplateManager(config) {\n    const { renderSettings, notificationToTemplateName, templateSettings } = config;\n    const { defaultStrategyName, strategies, cdRef: injectingViewCdRef, patchZone, parent, } = renderSettings;\n    const errorHandler = createErrorHandler(renderSettings.errorHandler);\n    const ngZone = patchZone ? patchZone : undefined;\n    let activeTemplate;\n    const strategyHandling$ = strategyHandling(defaultStrategyName, strategies);\n    const templates = templateHandling(templateSettings.viewContainerRef);\n    const viewContainerRef = templateSettings.viewContainerRef;\n    const triggerHandling = config.templateTrigger$ || EMPTY;\n    const getContext = notificationKindToViewContext(templateSettings.customContext || (() => ({})));\n    return {\n        addTemplateRef: (name, templateRef) => {\n            templates.add(name, templateRef);\n        },\n        nextStrategy: strategyHandling$.next,\n        render(values$) {\n            let trg;\n            let notification = {\n                value: undefined,\n                complete: false,\n                error: false,\n                kind: \"suspense\" /* Suspense */,\n                hasValue: false,\n            };\n            return merge(values$.pipe(tap((n) => (notification = n))), triggerHandling.pipe(tap((trigger) => (trg = trigger)))).pipe(map(() => {\n                const contextKind = trg || notification.kind;\n                trg = undefined;\n                const value = notification.value;\n                const templateName = notificationToTemplateName[contextKind](value, templates);\n                const template = templates.get(templateName);\n                return { template, templateName, notification, contextKind };\n            }), withLatestFrom(strategyHandling$.strategy$), \n            // Cancel old renders\n            switchMap(([{ template, templateName, notification, contextKind }, strategy,]) => {\n                const isNewTemplate = activeTemplate !== templateName || !template;\n                const notifyParent = isNewTemplate && parent;\n                return onStrategy(notification.value, strategy, (v, work, options) => {\n                    const context = getContext[contextKind](notification);\n                    if (isNewTemplate) {\n                        // template has changed (undefined => next; suspense => next; ...)\n                        // handle remove & insert\n                        // remove current view if there is any\n                        if (viewContainerRef.length > 0) {\n                            // patch removal if needed\n                            viewContainerRef.clear();\n                        }\n                        // create new view if any\n                        if (template) {\n                            // createEmbeddedView is already patched, no need for workFactory\n                            templates.createEmbeddedView(templateName, context);\n                        }\n                    }\n                    else if (template) {\n                        // template didn't change, update it\n                        // handle update\n                        const view = viewContainerRef.get(0);\n                        Object.keys(context).forEach((k) => {\n                            view.context[k] = context[k];\n                        });\n                        // update view context, patch if needed\n                        work(view, options.scope, notification);\n                    }\n                    activeTemplate = templateName;\n                }, { ngZone }\n                // we don't need to specify any scope here. The template manager is the only one\n                // who will call `viewRef#detectChanges` on any of the templates it manages.\n                // whenever a new value comes in, any pre-scheduled work of this taskManager will\n                // be nooped before a new work will be scheduled. This happens because of the implementation\n                // of `StrategyCredential#behavior`\n                ).pipe(notifyAllParentsIfNeeded(injectingViewCdRef, strategy, () => notifyParent, ngZone), catchError((e) => {\n                    errorHandler.handleError(e);\n                    return of(e);\n                }));\n            }));\n        },\n    };\n}\n\n/**\n * @internal\n *\n * Factory that returns a `ListTemplateManager` for the passed params.\n *\n * @param templateSettings\n */\nfunction getTemplateHandler(templateSettings) {\n    const { viewContainerRef, initialTemplateRef, createViewContext, updateViewContext, } = templateSettings;\n    return {\n        updateUnchangedContext,\n        insertView,\n        moveView,\n        removeView,\n        getListChanges,\n        updateView,\n    };\n    // =====\n    function updateUnchangedContext(item, index, count) {\n        const view = viewContainerRef.get(index);\n        updateViewContext(item, view, {\n            count,\n            index,\n        });\n        view.detectChanges();\n    }\n    function moveView(oldIndex, item, index, count) {\n        const oldView = viewContainerRef.get(oldIndex);\n        const view = viewContainerRef.move(oldView, index);\n        updateViewContext(item, view, {\n            count,\n            index,\n        });\n        view.detectChanges();\n    }\n    function updateView(item, index, count) {\n        const view = viewContainerRef.get(index);\n        updateViewContext(item, view, {\n            count,\n            index,\n        });\n        view.detectChanges();\n    }\n    function removeView(index) {\n        return viewContainerRef.remove(index);\n    }\n    function insertView(item, index, count) {\n        createEmbeddedView(viewContainerRef, initialTemplateRef, createViewContext(item, {\n            count,\n            index,\n        }), index);\n    }\n}\n/**\n * @internal\n *\n * @param changes\n * @param items\n */\nfunction getListChanges(changes, items) {\n    const changedIdxs = new Set();\n    const changesArr = [];\n    let notifyParent = false;\n    changes.forEachOperation((record, adjustedPreviousIndex, currentIndex) => {\n        const item = record.item;\n        if (record.previousIndex == null) {\n            // insert\n            changesArr.push(getInsertChange(item, currentIndex === null ? undefined : currentIndex));\n            changedIdxs.add(item);\n            notifyParent = true;\n        }\n        else if (currentIndex == null) {\n            // remove\n            changesArr.push(getRemoveChange(item, adjustedPreviousIndex === null ? undefined : adjustedPreviousIndex));\n            notifyParent = true;\n        }\n        else if (adjustedPreviousIndex !== null) {\n            // move\n            changesArr.push(getMoveChange(item, currentIndex, adjustedPreviousIndex));\n            changedIdxs.add(item);\n            notifyParent = true;\n        }\n    });\n    changes.forEachIdentityChange((record) => {\n        const item = record.item;\n        if (!changedIdxs.has(item)) {\n            changesArr.push(getUpdateChange(item, record.currentIndex));\n            changedIdxs.add(item);\n        }\n    });\n    items.forEach((item, index) => {\n        if (!changedIdxs.has(item)) {\n            changesArr.push(getUnchangedChange(item, index));\n        }\n    });\n    return [changesArr, notifyParent];\n    // ==========\n    function getMoveChange(item, currentIndex, adjustedPreviousIndex) {\n        return [\n            2 /* move */,\n            [item, currentIndex, adjustedPreviousIndex],\n        ];\n    }\n    function getUpdateChange(item, currentIndex) {\n        return [3 /* update */, [item, currentIndex]];\n    }\n    function getUnchangedChange(item, index) {\n        return [4 /* context */, [item, index]];\n    }\n    function getInsertChange(item, currentIndex) {\n        return [\n            0 /* insert */,\n            [item, currentIndex === null ? undefined : currentIndex],\n        ];\n    }\n    function getRemoveChange(item, adjustedPreviousIndex) {\n        return [\n            1 /* remove */,\n            [\n                item,\n                adjustedPreviousIndex === null ? undefined : adjustedPreviousIndex,\n            ],\n        ];\n    }\n}\n\nfunction createListTemplateManager(config) {\n    const { templateSettings, renderSettings, trackBy, iterableDiffers } = config;\n    const { defaultStrategyName, strategies, cdRef: injectingViewCdRef, patchZone, parent, } = renderSettings;\n    const errorHandler = createErrorHandler(renderSettings.errorHandler);\n    const ngZone = patchZone ? patchZone : undefined;\n    const strategyHandling$ = strategyHandling(defaultStrategyName, strategies);\n    let _differ;\n    function getDiffer(values) {\n        if (_differ) {\n            return _differ;\n        }\n        return values\n            ? (_differ = iterableDiffers.find(values).create(trackBy))\n            : null;\n    }\n    //               type,  context\n    /* TODO (regarding createView): this is currently not in use. for the list-manager this would mean to provide\n     functions for not only create. developers than should have to provide create, move, remove,... the whole thing.\n     i don't know if this is the right decision for a first RC */\n    const listViewHandler = getTemplateHandler(Object.assign(Object.assign({}, templateSettings), { initialTemplateRef: templateSettings.templateRef }));\n    const viewContainerRef = templateSettings.viewContainerRef;\n    let notifyParent = false;\n    let changesArr;\n    let partiallyFinished = false;\n    return {\n        nextStrategy(nextConfig) {\n            strategyHandling$.next(nextConfig);\n        },\n        render(values$) {\n            return values$.pipe(render());\n        },\n    };\n    function handleError() {\n        return (o$) => o$.pipe(catchError((err) => {\n            partiallyFinished = false;\n            errorHandler.handleError(err);\n            return of(null);\n        }));\n    }\n    function render() {\n        return (o$) => combineLatest([\n            o$,\n            strategyHandling$.strategy$.pipe(distinctUntilChanged()),\n        ]).pipe(map(([iterable, strategy]) => {\n            const differ = getDiffer(iterable);\n            let changes;\n            if (differ) {\n                if (partiallyFinished) {\n                    const currentIterable = [];\n                    for (let i = 0, ilen = viewContainerRef.length; i < ilen; i++) {\n                        const viewRef = viewContainerRef.get(i);\n                        currentIterable[i] = viewRef.context.$implicit;\n                    }\n                    differ.diff(currentIterable);\n                }\n                changes = differ.diff(iterable);\n            }\n            return {\n                changes,\n                iterable,\n                strategy,\n            };\n        }), \n        // Cancel old renders\n        switchMap(({ changes, iterable, strategy }) => {\n            if (!changes) {\n                return of([]);\n            }\n            const values = iterable || [];\n            // TODO: we might want to treat other iterables in a more performant way than Array.from()\n            const items = Array.isArray(values) ? values : Array.from(iterable);\n            const listChanges = listViewHandler.getListChanges(changes, items);\n            changesArr = listChanges[0];\n            const insertedOrRemoved = listChanges[1];\n            const applyChanges$ = getObservablesFromChangesArray(changesArr, strategy, items.length);\n            partiallyFinished = true;\n            notifyParent = insertedOrRemoved && parent;\n            return combineLatest(applyChanges$.length > 0 ? applyChanges$ : [of(null)]).pipe(tap(() => (partiallyFinished = false)), notifyAllParentsIfNeeded(injectingViewCdRef, strategy, () => notifyParent, ngZone), handleError(), map(() => iterable));\n        }), handleError());\n    }\n    /**\n     * @internal\n     *\n     * returns an array of streams which process all of the view updates needed to reflect the latest diff to the\n     * viewContainer.\n     * I\n     *\n     * @param changes\n     * @param strategy\n     * @param count\n     */\n    function getObservablesFromChangesArray(changes, strategy, count) {\n        return changes.length > 0\n            ? changes.map((change) => {\n                const payload = change[1];\n                return onStrategy(change[0], strategy, (type) => {\n                    switch (type) {\n                        case 0 /* insert */:\n                            listViewHandler.insertView(payload[0], payload[1], count);\n                            break;\n                        case 2 /* move */:\n                            listViewHandler.moveView(payload[2], payload[0], payload[1], count);\n                            break;\n                        case 1 /* remove */:\n                            listViewHandler.removeView(payload[1]);\n                            break;\n                        case 3 /* update */:\n                            listViewHandler.updateView(payload[0], payload[1], count);\n                            break;\n                        case 4 /* context */:\n                            listViewHandler.updateUnchangedContext(payload[0], payload[1], count);\n                            break;\n                    }\n                }, { ngZone });\n            })\n            : [of(null)];\n    }\n}\n\nconst computeFirst = ({ count, index }) => index === 0;\nconst computeLast = ({ count, index }) => index === count - 1;\nconst computeEven = ({ count, index }) => index % 2 === 0;\nclass RxDefaultListViewContext {\n    constructor(item, customProps) {\n        this._item = new ReplaySubject(1);\n        this.item$ = this._item.asObservable();\n        this._context$ = new BehaviorSubject({\n            index: -1,\n            count: -1,\n        });\n        this.select = (props) => {\n            return this.item$.pipe(pluck(...props));\n        };\n        this.$implicit = item;\n        if (customProps) {\n            this.updateContext(customProps);\n        }\n    }\n    set $implicit($implicit) {\n        this._$implicit = $implicit;\n        this._item.next($implicit);\n    }\n    get $implicit() {\n        return this._$implicit;\n    }\n    get $complete() {\n        return this._$complete;\n    }\n    get $error() {\n        return this._$error;\n    }\n    get $suspense() {\n        return this._$suspense;\n    }\n    get index() {\n        return this._context$.getValue().index;\n    }\n    get count() {\n        return this._context$.getValue().count;\n    }\n    get first() {\n        return computeFirst(this._context$.getValue());\n    }\n    get last() {\n        return computeLast(this._context$.getValue());\n    }\n    get even() {\n        return computeEven(this._context$.getValue());\n    }\n    get odd() {\n        return !this.even;\n    }\n    get index$() {\n        return this._context$.pipe(pluck('index'), distinctUntilChanged());\n    }\n    get count$() {\n        return this._context$.pipe(pluck('count'), distinctUntilChanged());\n    }\n    get first$() {\n        return this._context$.pipe(map(computeFirst), distinctUntilChanged());\n    }\n    get last$() {\n        return this._context$.pipe(map(computeLast), distinctUntilChanged());\n    }\n    get even$() {\n        return this._context$.pipe(map(computeEven), distinctUntilChanged());\n    }\n    get odd$() {\n        return this.even$.pipe(map((even) => !even));\n    }\n    updateContext(newProps) {\n        this._context$.next(Object.assign(Object.assign({}, this._context$.getValue()), newProps));\n    }\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { RxBaseTemplateNames, RxDefaultListViewContext, createListTemplateManager, createTemplateManager, templateHandling };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}