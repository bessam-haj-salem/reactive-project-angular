{"ast":null,"code":"import { ɵglobal } from '@angular/core';\n\nfunction push(heap, node) {\n  const index = heap.length;\n  heap.push(node);\n  siftUp(heap, node, index);\n}\n\nfunction peek(heap) {\n  const first = heap[0];\n  return first === undefined ? null : first;\n}\n\nfunction pop(heap) {\n  const first = heap[0];\n\n  if (first !== undefined) {\n    const last = heap.pop();\n\n    if (last !== first) {\n      heap[0] = last;\n      siftDown(heap, last, 0);\n    }\n\n    return first;\n  } else {\n    return null;\n  }\n}\n\nfunction siftUp(heap, node, i) {\n  let index = i; // eslint-disable-next-line no-constant-condition\n\n  while (true) {\n    const parentIndex = index - 1 >>> 1;\n    const parent = heap[parentIndex];\n\n    if (parent !== undefined && compare(parent, node) > 0) {\n      // The parent is larger. Swap positions.\n      heap[parentIndex] = node;\n      heap[index] = parent;\n      index = parentIndex;\n    } else {\n      // The parent is smaller. Exit.\n      return;\n    }\n  }\n}\n\nfunction siftDown(heap, node, i) {\n  let index = i;\n  const length = heap.length;\n\n  while (index < length) {\n    const leftIndex = (index + 1) * 2 - 1;\n    const left = heap[leftIndex];\n    const rightIndex = leftIndex + 1;\n    const right = heap[rightIndex]; // If the left or right node is smaller, swap with the smaller of those.\n\n    if (left !== undefined && compare(left, node) < 0) {\n      if (right !== undefined && compare(right, left) < 0) {\n        heap[index] = right;\n        heap[rightIndex] = node;\n        index = rightIndex;\n      } else {\n        heap[index] = left;\n        heap[leftIndex] = node;\n        index = leftIndex;\n      }\n    } else if (right !== undefined && compare(right, node) < 0) {\n      heap[index] = right;\n      heap[rightIndex] = node;\n      index = rightIndex;\n    } else {\n      // Neither child is smaller. Exit.\n      return;\n    }\n  }\n}\n\nfunction compare(a, b) {\n  // Compare sort index first, then task id.\n  const diff = a.sortIndex - b.sortIndex;\n  return diff !== 0 ? diff : a.id - b.id;\n} // see https://github.com/facebook/react/blob/main/packages/scheduler/src/forks/Scheduler.js\n\n\nlet getCurrentTime;\nconst hasPerformanceNow = typeof ɵglobal.performance === 'object' && typeof ɵglobal.performance.now === 'function';\n\nif (hasPerformanceNow) {\n  const localPerformance = ɵglobal.performance;\n\n  getCurrentTime = () => localPerformance.now();\n} else {\n  const localDate = Date;\n  const initialTime = localDate.now();\n\n  getCurrentTime = () => localDate.now() - initialTime;\n} // Max 31 bit integer. The max integer size in V8 for 32-bit systems.\n// Math.pow(2, 30) - 1\n// 0b111111111111111111111111111111\n\n\nconst maxSigned31BitInt = 1073741823; // Times out immediately\n\nconst IMMEDIATE_PRIORITY_TIMEOUT = -1; // Eventually times out\n\nconst USER_BLOCKING_PRIORITY_TIMEOUT = 250;\nconst NORMAL_PRIORITY_TIMEOUT = 5000;\nconst LOW_PRIORITY_TIMEOUT = 10000; // Never times out\n\nconst IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt; // Tasks are stored on a min heap\n\nconst taskQueue = [];\nconst timerQueue = []; // Incrementing id counter. Used to maintain insertion order.\n\nlet taskIdCounter = 1; // Pausing the scheduler is useful for debugging.\n\nlet isSchedulerPaused = false;\nlet currentTask = null;\nlet currentPriorityLevel = 3\n/* NormalPriority */\n; // This is set while performing work, to prevent re-entrancy.\n\nlet isPerformingWork = false;\nlet isHostCallbackScheduled = false;\nlet isHostTimeoutScheduled = false; // Capture local references to native APIs, in case a polyfill overrides them.\n\nconst setTimeout = ɵglobal.setTimeout;\nconst clearTimeout = ɵglobal.clearTimeout;\nconst setImmediate = ɵglobal.setImmediate; // IE and Node.js + jsdom\n\nconst messageChannel = ɵglobal.MessageChannel;\nconst isInputPending = typeof ɵglobal.navigator !== 'undefined' && ɵglobal.navigator.scheduling !== undefined && ɵglobal.navigator.scheduling.isInputPending !== undefined ? ɵglobal.navigator.scheduling.isInputPending.bind(ɵglobal.navigator.scheduling) : null;\nconst defaultZone = {\n  run: fn => fn()\n};\n\nfunction advanceTimers(currentTime) {\n  // Check for tasks that are no longer delayed and add them to the queue.\n  let timer = peek(timerQueue);\n\n  while (timer !== null) {\n    if (timer.callback === null) {\n      // Timer was cancelled.\n      pop(timerQueue);\n    } else if (timer.startTime <= currentTime) {\n      // Timer fired. Transfer to the task queue.\n      pop(timerQueue);\n      timer.sortIndex = timer.expirationTime;\n      push(taskQueue, timer);\n    } else {\n      // Remaining timers are pending.\n      return;\n    }\n\n    timer = peek(timerQueue);\n  }\n}\n\nfunction handleTimeout(currentTime) {\n  isHostTimeoutScheduled = false;\n  advanceTimers(currentTime);\n\n  if (!isHostCallbackScheduled) {\n    if (peek(taskQueue) !== null) {\n      isHostCallbackScheduled = true;\n      requestHostCallback(flushWork);\n    } else {\n      const firstTimer = peek(timerQueue);\n\n      if (firstTimer !== null) {\n        requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n      }\n    }\n  }\n}\n\nfunction flushWork(hasTimeRemaining, initialTime) {\n  // We'll need a host callback the next time work is scheduled.\n  isHostCallbackScheduled = false;\n\n  if (isHostTimeoutScheduled) {\n    // We scheduled a timeout but it's no longer needed. Cancel it.\n    isHostTimeoutScheduled = false;\n    cancelHostTimeout();\n  }\n\n  isPerformingWork = true;\n  const previousPriorityLevel = currentPriorityLevel;\n\n  try {\n    return workLoop(hasTimeRemaining, initialTime);\n  } finally {\n    currentTask = null;\n    currentPriorityLevel = previousPriorityLevel;\n    isPerformingWork = false;\n  }\n}\n\nfunction workLoop(hasTimeRemaining, initialTime, _currentTask) {\n  let currentTime = initialTime;\n\n  if (_currentTask) {\n    currentTask = _currentTask;\n  } else {\n    advanceTimers(currentTime);\n    currentTask = peek(taskQueue);\n  }\n\n  let zoneChanged = false;\n\n  const hitDeadline = () => currentTask && currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost());\n\n  if (!hitDeadline()) {\n    const ngZone = currentTask.ngZone || defaultZone;\n    ngZone.run(() => {\n      while (currentTask !== null && !zoneChanged) {\n        if (hitDeadline()) {\n          break;\n        }\n\n        const callback = currentTask.callback;\n\n        if (typeof callback === 'function') {\n          currentTask.callback = null;\n          currentPriorityLevel = currentTask.priorityLevel;\n          const didUserCallbackTimeout = currentTask.expirationTime <= currentTime;\n          const continuationCallback = callback(didUserCallbackTimeout);\n          currentTime = getCurrentTime();\n\n          if (typeof continuationCallback === 'function') {\n            currentTask.callback = continuationCallback;\n          } else {\n            if (currentTask === peek(taskQueue)) {\n              pop(taskQueue);\n            }\n          }\n\n          advanceTimers(currentTime);\n        } else {\n          pop(taskQueue);\n        }\n\n        currentTask = peek(taskQueue);\n        zoneChanged = (currentTask === null || currentTask === void 0 ? void 0 : currentTask.ngZone) != null && currentTask.ngZone !== ngZone;\n      }\n    });\n  }\n\n  if (zoneChanged) {\n    return workLoop(hasTimeRemaining, currentTime, currentTask);\n  } // Return whether there's additional work\n\n\n  if (currentTask !== null) {\n    return true;\n  } else {\n    const firstTimer = peek(timerQueue);\n\n    if (firstTimer !== null) {\n      requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n    }\n\n    return false;\n  }\n}\n\nfunction runWithPriority(priorityLevel, eventHandler) {\n  switch (priorityLevel) {\n    case 1\n    /* ImmediatePriority */\n    :\n    case 2\n    /* UserBlockingPriority */\n    :\n    case 3\n    /* NormalPriority */\n    :\n    case 4\n    /* LowPriority */\n    :\n    case 5\n    /* IdlePriority */\n    :\n      break;\n\n    default:\n      priorityLevel = 3\n      /* NormalPriority */\n      ;\n  }\n\n  const previousPriorityLevel = currentPriorityLevel;\n  currentPriorityLevel = priorityLevel;\n\n  try {\n    return eventHandler();\n  } finally {\n    currentPriorityLevel = previousPriorityLevel;\n  }\n}\n\nfunction next(eventHandler) {\n  let priorityLevel;\n\n  switch (currentPriorityLevel) {\n    case 1\n    /* ImmediatePriority */\n    :\n    case 2\n    /* UserBlockingPriority */\n    :\n    case 3\n    /* NormalPriority */\n    :\n      // Shift down to normal priority\n      priorityLevel = 3\n      /* NormalPriority */\n      ;\n      break;\n\n    default:\n      // Anything lower than normal priority should remain at the current level.\n      priorityLevel = currentPriorityLevel;\n      break;\n  }\n\n  const previousPriorityLevel = currentPriorityLevel;\n  currentPriorityLevel = priorityLevel;\n\n  try {\n    return eventHandler();\n  } finally {\n    currentPriorityLevel = previousPriorityLevel;\n  }\n}\n\nfunction wrapCallback(callback) {\n  const parentPriorityLevel = currentPriorityLevel;\n  return () => {\n    // This is a fork of runWithPriority, inlined for performance.\n    const previousPriorityLevel = currentPriorityLevel;\n    currentPriorityLevel = parentPriorityLevel;\n\n    try {\n      // eslint-disable-next-line prefer-rest-params\n      return callback.apply(this, arguments);\n    } finally {\n      currentPriorityLevel = previousPriorityLevel;\n    }\n  };\n}\n\nfunction scheduleCallback(priorityLevel, callback, options) {\n  const currentTime = getCurrentTime();\n  let startTime;\n\n  if (typeof options === 'object' && options !== null) {\n    const delay = options.delay;\n\n    if (typeof delay === 'number' && delay > 0) {\n      startTime = currentTime + delay;\n    } else {\n      startTime = currentTime;\n    }\n  } else {\n    startTime = currentTime;\n  }\n\n  let timeout;\n\n  switch (priorityLevel) {\n    case 1\n    /* ImmediatePriority */\n    :\n      timeout = IMMEDIATE_PRIORITY_TIMEOUT;\n      break;\n\n    case 2\n    /* UserBlockingPriority */\n    :\n      timeout = USER_BLOCKING_PRIORITY_TIMEOUT;\n      break;\n\n    case 5\n    /* IdlePriority */\n    :\n      timeout = IDLE_PRIORITY_TIMEOUT;\n      break;\n\n    case 4\n    /* LowPriority */\n    :\n      timeout = LOW_PRIORITY_TIMEOUT;\n      break;\n\n    case 3\n    /* NormalPriority */\n    :\n    default:\n      timeout = NORMAL_PRIORITY_TIMEOUT;\n      break;\n  }\n\n  const expirationTime = startTime + timeout;\n  const newTask = {\n    id: taskIdCounter++,\n    callback,\n    priorityLevel,\n    startTime,\n    expirationTime,\n    sortIndex: -1,\n    ngZone: (options === null || options === void 0 ? void 0 : options.ngZone) || null\n  };\n\n  if (startTime > currentTime) {\n    // This is a delayed task.\n    newTask.sortIndex = startTime;\n    push(timerQueue, newTask);\n\n    if (peek(taskQueue) === null && newTask === peek(timerQueue)) {\n      // All tasks are delayed, and this is the task with the earliest delay.\n      if (isHostTimeoutScheduled) {\n        // Cancel an existing timeout.\n        cancelHostTimeout();\n      } else {\n        isHostTimeoutScheduled = true;\n      } // Schedule a timeout.\n\n\n      requestHostTimeout(handleTimeout, startTime - currentTime);\n    }\n  } else {\n    newTask.sortIndex = expirationTime;\n    push(taskQueue, newTask); // Schedule a host callback, if needed. If we're already performing work,\n    // wait until the next time we yield.\n\n    if (!isHostCallbackScheduled && !isPerformingWork) {\n      isHostCallbackScheduled = true;\n      requestHostCallback(flushWork);\n    }\n  }\n\n  return newTask;\n}\n\nfunction pauseExecution() {\n  isSchedulerPaused = true;\n}\n\nfunction continueExecution() {\n  isSchedulerPaused = false;\n\n  if (!isHostCallbackScheduled && !isPerformingWork) {\n    isHostCallbackScheduled = true;\n    requestHostCallback(flushWork);\n  }\n}\n\nfunction getFirstCallbackNode() {\n  return peek(taskQueue);\n}\n\nfunction cancelCallback(task) {\n  // Null out the callback to indicate the task has been canceled. (Can't\n  // remove from the queue because you can't remove arbitrary nodes from an\n  // array based heap, only the first one.)\n  task.callback = null;\n}\n\nfunction getCurrentPriorityLevel() {\n  return currentPriorityLevel;\n}\n\nlet isMessageLoopRunning = false;\nlet scheduledHostCallback = null;\nlet taskTimeoutID = -1; // Scheduler periodically yields in case there is other work on the main\n// thread, like user events. By default, it yields multiple times per frame.\n// It does not attempt to align with frame boundaries, since most tasks don't\n// need to be frame aligned; for those that do, use requestAnimationFrame.\n\nlet yieldInterval = 16; // TODO: Make this configurable\n// TODO: Adjust this based on priority?\n\nconst maxYieldInterval = 300;\nlet needsPaint = false;\nlet queueStartTime = -1;\n\nfunction shouldYieldToHost() {\n  if (needsPaint) {\n    // There's a pending paint (signaled by `requestPaint`). Yield now.\n    return true;\n  }\n\n  const timeElapsed = getCurrentTime() - queueStartTime;\n\n  if (timeElapsed < yieldInterval) {\n    // The main thread has only been blocked for a really short amount of time;\n    // smaller than a single frame. Don't yield yet.\n    return false;\n  } // The main thread has been blocked for a non-negligible amount of time. We\n  // may want to yield control of the main thread, so the browser can perform\n  // high priority tasks. The main ones are painting and user input. If there's\n  // a pending paint or a pending input, then we should yield. But if there's\n  // neither, then we can yield less often while remaining responsive. We'll\n  // eventually yield regardless, since there could be a pending paint that\n  // wasn't accompanied by a call to `requestPaint`, or other main thread tasks\n  // like network events.\n  // we don't support isInputPending currently\n\n  /*if (enableIsInputPending) {\n    if (needsPaint) {\n      // There's a pending paint (signaled by `requestPaint`). Yield now.\n      return true;\n    }\n    if (timeElapsed < continuousInputInterval) {\n      // We haven't blocked the thread for that long. Only yield if there's a\n      // pending discrete input (e.g. click). It's OK if there's pending\n      // continuous input (e.g. mouseover).\n      if (isInputPending !== null) {\n        return isInputPending();\n      }\n    } else if (timeElapsed < maxInterval) {\n      // Yield if there's either a pending discrete or continuous input.\n      if (isInputPending !== null) {\n        return isInputPending(continuousOptions);\n      }\n    } else {\n      // We've blocked the thread for a long time. Even if there's no pending\n      // input, there may be some other scheduled work that we don't know about,\n      // like a network event. Yield now.\n      return true;\n    }\n  }*/\n  // `isInputPending` isn't available. Yield now.\n\n\n  return true;\n}\n\nfunction requestPaint() {\n  needsPaint = true; // we don't support isInputPending currently\n\n  /*if (\n    enableIsInputPending &&\n    navigator !== undefined &&\n    (navigator as any).scheduling !== undefined &&\n    (navigator as any).scheduling.isInputPending !== undefined\n  ) {\n    needsPaint = true;\n  }*/\n}\n\nfunction forceFrameRate(fps) {\n  if (fps < 0 || fps > 125) {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      console.error('forceFrameRate takes a positive int between 0 and 125, ' + 'forcing frame rates higher than 125 fps is not supported');\n    }\n\n    return;\n  }\n\n  if (fps > 0) {\n    yieldInterval = Math.floor(1000 / fps);\n  } else {\n    // reset the framerate\n    yieldInterval = 5;\n  } // be aware of browser housekeeping work (~6ms per frame)\n  // according to https://developers.google.com/web/fundamentals/performance/rendering\n\n\n  yieldInterval = Math.max(5, yieldInterval - 6);\n}\n\nconst performWorkUntilDeadline = () => {\n  if (scheduledHostCallback !== null) {\n    const currentTime = getCurrentTime(); // Yield after `yieldInterval` ms, regardless of where we are in the vsync\n    // cycle. This means there's always time remaining at the beginning of\n    // the message event.\n\n    queueStartTime = currentTime;\n    const hasTimeRemaining = true; // If a scheduler task throws, exit the current browser task so the\n    // error can be observed.\n    //\n    // Intentionally not using a try-catch, since that makes some debugging\n    // techniques harder. Instead, if `scheduledHostCallback` errors, then\n    // `hasMoreWork` will remain true, and we'll continue the work loop.\n\n    let hasMoreWork = true;\n\n    try {\n      hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);\n    } finally {\n      if (hasMoreWork) {\n        // If there's more work, schedule the next message event at the end\n        // of the preceding one.\n        schedulePerformWorkUntilDeadline();\n      } else {\n        isMessageLoopRunning = false;\n        scheduledHostCallback = null;\n      }\n    }\n  } else {\n    isMessageLoopRunning = false;\n  } // Yielding to the browser will give it a chance to paint, so we can\n  // reset this.\n\n\n  needsPaint = false;\n};\n\nlet schedulePerformWorkUntilDeadline;\n\nif (typeof setImmediate === 'function') {\n  // Node.js and old IE.\n  // There's a few reasons for why we prefer setImmediate.\n  //\n  // Unlike MessageChannel, it doesn't prevent a Node.js process from exiting.\n  // (Even though this is a DOM fork of the Scheduler, you could get here\n  // with a mix of Node.js 15+, which has a MessageChannel, and jsdom.)\n  // https://github.com/facebook/react/issues/20756\n  //\n  // But also, it runs earlier which is the semantic we want.\n  // If other browsers ever implement it, it's better to use it.\n  // Although both of these would be inferior to native scheduling.\n  schedulePerformWorkUntilDeadline = () => {\n    setImmediate(performWorkUntilDeadline);\n  };\n} else if (typeof messageChannel !== 'undefined') {\n  const channel = new messageChannel();\n  const port = channel.port2;\n  channel.port1.onmessage = performWorkUntilDeadline;\n\n  schedulePerformWorkUntilDeadline = () => {\n    port.postMessage(null);\n  };\n} else {\n  // We should only fallback here in non-browser environments.\n  schedulePerformWorkUntilDeadline = () => {\n    setTimeout(performWorkUntilDeadline, 0);\n  };\n}\n\nfunction requestHostCallback(callback) {\n  scheduledHostCallback = callback;\n\n  if (!isMessageLoopRunning) {\n    isMessageLoopRunning = true;\n    schedulePerformWorkUntilDeadline();\n  }\n}\n\nfunction requestHostTimeout(callback, ms) {\n  taskTimeoutID = setTimeout(() => {\n    callback(getCurrentTime());\n  }, ms);\n}\n\nfunction cancelHostTimeout() {\n  clearTimeout(taskTimeoutID);\n  taskTimeoutID = -1;\n}\n\nconst _requestPaint = requestPaint;\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { cancelCallback, forceFrameRate, scheduleCallback };","map":{"version":3,"names":["ɵglobal","push","heap","node","index","length","siftUp","peek","first","undefined","pop","last","siftDown","i","parentIndex","parent","compare","leftIndex","left","rightIndex","right","a","b","diff","sortIndex","id","getCurrentTime","hasPerformanceNow","performance","now","localPerformance","localDate","Date","initialTime","maxSigned31BitInt","IMMEDIATE_PRIORITY_TIMEOUT","USER_BLOCKING_PRIORITY_TIMEOUT","NORMAL_PRIORITY_TIMEOUT","LOW_PRIORITY_TIMEOUT","IDLE_PRIORITY_TIMEOUT","taskQueue","timerQueue","taskIdCounter","isSchedulerPaused","currentTask","currentPriorityLevel","isPerformingWork","isHostCallbackScheduled","isHostTimeoutScheduled","setTimeout","clearTimeout","setImmediate","messageChannel","MessageChannel","isInputPending","navigator","scheduling","bind","defaultZone","run","fn","advanceTimers","currentTime","timer","callback","startTime","expirationTime","handleTimeout","requestHostCallback","flushWork","firstTimer","requestHostTimeout","hasTimeRemaining","cancelHostTimeout","previousPriorityLevel","workLoop","_currentTask","zoneChanged","hitDeadline","shouldYieldToHost","ngZone","priorityLevel","didUserCallbackTimeout","continuationCallback","runWithPriority","eventHandler","next","wrapCallback","parentPriorityLevel","apply","arguments","scheduleCallback","options","delay","timeout","newTask","pauseExecution","continueExecution","getFirstCallbackNode","cancelCallback","task","getCurrentPriorityLevel","isMessageLoopRunning","scheduledHostCallback","taskTimeoutID","yieldInterval","maxYieldInterval","needsPaint","queueStartTime","timeElapsed","requestPaint","forceFrameRate","fps","ngDevMode","console","error","Math","floor","max","performWorkUntilDeadline","hasMoreWork","schedulePerformWorkUntilDeadline","channel","port","port2","port1","onmessage","postMessage","ms","_requestPaint"],"sources":["/home/bessam/Documents/Medisail/angular/angular interview/reactive-project-angular/node_modules/@rx-angular/cdk/fesm2015/cdk-internals-scheduler.js"],"sourcesContent":["import { ɵglobal } from '@angular/core';\n\nfunction push(heap, node) {\n    const index = heap.length;\n    heap.push(node);\n    siftUp(heap, node, index);\n}\nfunction peek(heap) {\n    const first = heap[0];\n    return first === undefined ? null : first;\n}\nfunction pop(heap) {\n    const first = heap[0];\n    if (first !== undefined) {\n        const last = heap.pop();\n        if (last !== first) {\n            heap[0] = last;\n            siftDown(heap, last, 0);\n        }\n        return first;\n    }\n    else {\n        return null;\n    }\n}\nfunction siftUp(heap, node, i) {\n    let index = i;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        const parentIndex = (index - 1) >>> 1;\n        const parent = heap[parentIndex];\n        if (parent !== undefined && compare(parent, node) > 0) {\n            // The parent is larger. Swap positions.\n            heap[parentIndex] = node;\n            heap[index] = parent;\n            index = parentIndex;\n        }\n        else {\n            // The parent is smaller. Exit.\n            return;\n        }\n    }\n}\nfunction siftDown(heap, node, i) {\n    let index = i;\n    const length = heap.length;\n    while (index < length) {\n        const leftIndex = (index + 1) * 2 - 1;\n        const left = heap[leftIndex];\n        const rightIndex = leftIndex + 1;\n        const right = heap[rightIndex];\n        // If the left or right node is smaller, swap with the smaller of those.\n        if (left !== undefined && compare(left, node) < 0) {\n            if (right !== undefined && compare(right, left) < 0) {\n                heap[index] = right;\n                heap[rightIndex] = node;\n                index = rightIndex;\n            }\n            else {\n                heap[index] = left;\n                heap[leftIndex] = node;\n                index = leftIndex;\n            }\n        }\n        else if (right !== undefined && compare(right, node) < 0) {\n            heap[index] = right;\n            heap[rightIndex] = node;\n            index = rightIndex;\n        }\n        else {\n            // Neither child is smaller. Exit.\n            return;\n        }\n    }\n}\nfunction compare(a, b) {\n    // Compare sort index first, then task id.\n    const diff = a.sortIndex - b.sortIndex;\n    return diff !== 0 ? diff : a.id - b.id;\n}\n\n// see https://github.com/facebook/react/blob/main/packages/scheduler/src/forks/Scheduler.js\nlet getCurrentTime;\nconst hasPerformanceNow = typeof ɵglobal.performance === 'object' && typeof ɵglobal.performance.now === 'function';\nif (hasPerformanceNow) {\n    const localPerformance = ɵglobal.performance;\n    getCurrentTime = () => localPerformance.now();\n}\nelse {\n    const localDate = Date;\n    const initialTime = localDate.now();\n    getCurrentTime = () => localDate.now() - initialTime;\n}\n// Max 31 bit integer. The max integer size in V8 for 32-bit systems.\n// Math.pow(2, 30) - 1\n// 0b111111111111111111111111111111\nconst maxSigned31BitInt = 1073741823;\n// Times out immediately\nconst IMMEDIATE_PRIORITY_TIMEOUT = -1;\n// Eventually times out\nconst USER_BLOCKING_PRIORITY_TIMEOUT = 250;\nconst NORMAL_PRIORITY_TIMEOUT = 5000;\nconst LOW_PRIORITY_TIMEOUT = 10000;\n// Never times out\nconst IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt;\n// Tasks are stored on a min heap\nconst taskQueue = [];\nconst timerQueue = [];\n// Incrementing id counter. Used to maintain insertion order.\nlet taskIdCounter = 1;\n// Pausing the scheduler is useful for debugging.\nlet isSchedulerPaused = false;\nlet currentTask = null;\nlet currentPriorityLevel = 3 /* NormalPriority */;\n// This is set while performing work, to prevent re-entrancy.\nlet isPerformingWork = false;\nlet isHostCallbackScheduled = false;\nlet isHostTimeoutScheduled = false;\n// Capture local references to native APIs, in case a polyfill overrides them.\nconst setTimeout = ɵglobal.setTimeout;\nconst clearTimeout = ɵglobal.clearTimeout;\nconst setImmediate = ɵglobal.setImmediate; // IE and Node.js + jsdom\nconst messageChannel = ɵglobal.MessageChannel;\nconst isInputPending = typeof ɵglobal.navigator !== 'undefined' &&\n    ɵglobal.navigator.scheduling !== undefined &&\n    ɵglobal.navigator.scheduling.isInputPending !== undefined\n    ? ɵglobal.navigator.scheduling.isInputPending.bind(ɵglobal.navigator.scheduling)\n    : null;\nconst defaultZone = {\n    run: fn => fn()\n};\nfunction advanceTimers(currentTime) {\n    // Check for tasks that are no longer delayed and add them to the queue.\n    let timer = peek(timerQueue);\n    while (timer !== null) {\n        if (timer.callback === null) {\n            // Timer was cancelled.\n            pop(timerQueue);\n        }\n        else if (timer.startTime <= currentTime) {\n            // Timer fired. Transfer to the task queue.\n            pop(timerQueue);\n            timer.sortIndex = timer.expirationTime;\n            push(taskQueue, timer);\n        }\n        else {\n            // Remaining timers are pending.\n            return;\n        }\n        timer = peek(timerQueue);\n    }\n}\nfunction handleTimeout(currentTime) {\n    isHostTimeoutScheduled = false;\n    advanceTimers(currentTime);\n    if (!isHostCallbackScheduled) {\n        if (peek(taskQueue) !== null) {\n            isHostCallbackScheduled = true;\n            requestHostCallback(flushWork);\n        }\n        else {\n            const firstTimer = peek(timerQueue);\n            if (firstTimer !== null) {\n                requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n            }\n        }\n    }\n}\nfunction flushWork(hasTimeRemaining, initialTime) {\n    // We'll need a host callback the next time work is scheduled.\n    isHostCallbackScheduled = false;\n    if (isHostTimeoutScheduled) {\n        // We scheduled a timeout but it's no longer needed. Cancel it.\n        isHostTimeoutScheduled = false;\n        cancelHostTimeout();\n    }\n    isPerformingWork = true;\n    const previousPriorityLevel = currentPriorityLevel;\n    try {\n        return workLoop(hasTimeRemaining, initialTime);\n    }\n    finally {\n        currentTask = null;\n        currentPriorityLevel = previousPriorityLevel;\n        isPerformingWork = false;\n    }\n}\nfunction workLoop(hasTimeRemaining, initialTime, _currentTask) {\n    let currentTime = initialTime;\n    if (_currentTask) {\n        currentTask = _currentTask;\n    }\n    else {\n        advanceTimers(currentTime);\n        currentTask = peek(taskQueue);\n    }\n    let zoneChanged = false;\n    const hitDeadline = () => currentTask && currentTask.expirationTime > currentTime &&\n        (!hasTimeRemaining || shouldYieldToHost());\n    if (!hitDeadline()) {\n        const ngZone = currentTask.ngZone || defaultZone;\n        ngZone.run(() => {\n            while (currentTask !== null && !zoneChanged) {\n                if (hitDeadline()) {\n                    break;\n                }\n                const callback = currentTask.callback;\n                if (typeof callback === 'function') {\n                    currentTask.callback = null;\n                    currentPriorityLevel = currentTask.priorityLevel;\n                    const didUserCallbackTimeout = currentTask.expirationTime <= currentTime;\n                    const continuationCallback = callback(didUserCallbackTimeout);\n                    currentTime = getCurrentTime();\n                    if (typeof continuationCallback === 'function') {\n                        currentTask.callback = continuationCallback;\n                    }\n                    else {\n                        if (currentTask === peek(taskQueue)) {\n                            pop(taskQueue);\n                        }\n                    }\n                    advanceTimers(currentTime);\n                }\n                else {\n                    pop(taskQueue);\n                }\n                currentTask = peek(taskQueue);\n                zoneChanged = (currentTask === null || currentTask === void 0 ? void 0 : currentTask.ngZone) != null && currentTask.ngZone !== ngZone;\n            }\n        });\n    }\n    if (zoneChanged) {\n        return workLoop(hasTimeRemaining, currentTime, currentTask);\n    }\n    // Return whether there's additional work\n    if (currentTask !== null) {\n        return true;\n    }\n    else {\n        const firstTimer = peek(timerQueue);\n        if (firstTimer !== null) {\n            requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n        }\n        return false;\n    }\n}\nfunction runWithPriority(priorityLevel, eventHandler) {\n    switch (priorityLevel) {\n        case 1 /* ImmediatePriority */:\n        case 2 /* UserBlockingPriority */:\n        case 3 /* NormalPriority */:\n        case 4 /* LowPriority */:\n        case 5 /* IdlePriority */:\n            break;\n        default:\n            priorityLevel = 3 /* NormalPriority */;\n    }\n    const previousPriorityLevel = currentPriorityLevel;\n    currentPriorityLevel = priorityLevel;\n    try {\n        return eventHandler();\n    }\n    finally {\n        currentPriorityLevel = previousPriorityLevel;\n    }\n}\nfunction next(eventHandler) {\n    let priorityLevel;\n    switch (currentPriorityLevel) {\n        case 1 /* ImmediatePriority */:\n        case 2 /* UserBlockingPriority */:\n        case 3 /* NormalPriority */:\n            // Shift down to normal priority\n            priorityLevel = 3 /* NormalPriority */;\n            break;\n        default:\n            // Anything lower than normal priority should remain at the current level.\n            priorityLevel = currentPriorityLevel;\n            break;\n    }\n    const previousPriorityLevel = currentPriorityLevel;\n    currentPriorityLevel = priorityLevel;\n    try {\n        return eventHandler();\n    }\n    finally {\n        currentPriorityLevel = previousPriorityLevel;\n    }\n}\nfunction wrapCallback(callback) {\n    const parentPriorityLevel = currentPriorityLevel;\n    return () => {\n        // This is a fork of runWithPriority, inlined for performance.\n        const previousPriorityLevel = currentPriorityLevel;\n        currentPriorityLevel = parentPriorityLevel;\n        try {\n            // eslint-disable-next-line prefer-rest-params\n            return callback.apply(this, arguments);\n        }\n        finally {\n            currentPriorityLevel = previousPriorityLevel;\n        }\n    };\n}\nfunction scheduleCallback(priorityLevel, callback, options) {\n    const currentTime = getCurrentTime();\n    let startTime;\n    if (typeof options === 'object' && options !== null) {\n        const delay = options.delay;\n        if (typeof delay === 'number' && delay > 0) {\n            startTime = currentTime + delay;\n        }\n        else {\n            startTime = currentTime;\n        }\n    }\n    else {\n        startTime = currentTime;\n    }\n    let timeout;\n    switch (priorityLevel) {\n        case 1 /* ImmediatePriority */:\n            timeout = IMMEDIATE_PRIORITY_TIMEOUT;\n            break;\n        case 2 /* UserBlockingPriority */:\n            timeout = USER_BLOCKING_PRIORITY_TIMEOUT;\n            break;\n        case 5 /* IdlePriority */:\n            timeout = IDLE_PRIORITY_TIMEOUT;\n            break;\n        case 4 /* LowPriority */:\n            timeout = LOW_PRIORITY_TIMEOUT;\n            break;\n        case 3 /* NormalPriority */:\n        default:\n            timeout = NORMAL_PRIORITY_TIMEOUT;\n            break;\n    }\n    const expirationTime = startTime + timeout;\n    const newTask = {\n        id: taskIdCounter++,\n        callback,\n        priorityLevel,\n        startTime,\n        expirationTime,\n        sortIndex: -1,\n        ngZone: (options === null || options === void 0 ? void 0 : options.ngZone) || null\n    };\n    if (startTime > currentTime) {\n        // This is a delayed task.\n        newTask.sortIndex = startTime;\n        push(timerQueue, newTask);\n        if (peek(taskQueue) === null && newTask === peek(timerQueue)) {\n            // All tasks are delayed, and this is the task with the earliest delay.\n            if (isHostTimeoutScheduled) {\n                // Cancel an existing timeout.\n                cancelHostTimeout();\n            }\n            else {\n                isHostTimeoutScheduled = true;\n            }\n            // Schedule a timeout.\n            requestHostTimeout(handleTimeout, startTime - currentTime);\n        }\n    }\n    else {\n        newTask.sortIndex = expirationTime;\n        push(taskQueue, newTask);\n        // Schedule a host callback, if needed. If we're already performing work,\n        // wait until the next time we yield.\n        if (!isHostCallbackScheduled && !isPerformingWork) {\n            isHostCallbackScheduled = true;\n            requestHostCallback(flushWork);\n        }\n    }\n    return newTask;\n}\nfunction pauseExecution() {\n    isSchedulerPaused = true;\n}\nfunction continueExecution() {\n    isSchedulerPaused = false;\n    if (!isHostCallbackScheduled && !isPerformingWork) {\n        isHostCallbackScheduled = true;\n        requestHostCallback(flushWork);\n    }\n}\nfunction getFirstCallbackNode() {\n    return peek(taskQueue);\n}\nfunction cancelCallback(task) {\n    // Null out the callback to indicate the task has been canceled. (Can't\n    // remove from the queue because you can't remove arbitrary nodes from an\n    // array based heap, only the first one.)\n    task.callback = null;\n}\nfunction getCurrentPriorityLevel() {\n    return currentPriorityLevel;\n}\nlet isMessageLoopRunning = false;\nlet scheduledHostCallback = null;\nlet taskTimeoutID = -1;\n// Scheduler periodically yields in case there is other work on the main\n// thread, like user events. By default, it yields multiple times per frame.\n// It does not attempt to align with frame boundaries, since most tasks don't\n// need to be frame aligned; for those that do, use requestAnimationFrame.\nlet yieldInterval = 16;\n// TODO: Make this configurable\n// TODO: Adjust this based on priority?\nconst maxYieldInterval = 300;\nlet needsPaint = false;\nlet queueStartTime = -1;\nfunction shouldYieldToHost() {\n    if (needsPaint) {\n        // There's a pending paint (signaled by `requestPaint`). Yield now.\n        return true;\n    }\n    const timeElapsed = getCurrentTime() - queueStartTime;\n    if (timeElapsed < yieldInterval) {\n        // The main thread has only been blocked for a really short amount of time;\n        // smaller than a single frame. Don't yield yet.\n        return false;\n    }\n    // The main thread has been blocked for a non-negligible amount of time. We\n    // may want to yield control of the main thread, so the browser can perform\n    // high priority tasks. The main ones are painting and user input. If there's\n    // a pending paint or a pending input, then we should yield. But if there's\n    // neither, then we can yield less often while remaining responsive. We'll\n    // eventually yield regardless, since there could be a pending paint that\n    // wasn't accompanied by a call to `requestPaint`, or other main thread tasks\n    // like network events.\n    // we don't support isInputPending currently\n    /*if (enableIsInputPending) {\n      if (needsPaint) {\n        // There's a pending paint (signaled by `requestPaint`). Yield now.\n        return true;\n      }\n      if (timeElapsed < continuousInputInterval) {\n        // We haven't blocked the thread for that long. Only yield if there's a\n        // pending discrete input (e.g. click). It's OK if there's pending\n        // continuous input (e.g. mouseover).\n        if (isInputPending !== null) {\n          return isInputPending();\n        }\n      } else if (timeElapsed < maxInterval) {\n        // Yield if there's either a pending discrete or continuous input.\n        if (isInputPending !== null) {\n          return isInputPending(continuousOptions);\n        }\n      } else {\n        // We've blocked the thread for a long time. Even if there's no pending\n        // input, there may be some other scheduled work that we don't know about,\n        // like a network event. Yield now.\n        return true;\n      }\n    }*/\n    // `isInputPending` isn't available. Yield now.\n    return true;\n}\nfunction requestPaint() {\n    needsPaint = true;\n    // we don't support isInputPending currently\n    /*if (\n      enableIsInputPending &&\n      navigator !== undefined &&\n      (navigator as any).scheduling !== undefined &&\n      (navigator as any).scheduling.isInputPending !== undefined\n    ) {\n      needsPaint = true;\n    }*/\n}\nfunction forceFrameRate(fps) {\n    if (fps < 0 || fps > 125) {\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            console.error('forceFrameRate takes a positive int between 0 and 125, ' +\n                'forcing frame rates higher than 125 fps is not supported');\n        }\n        return;\n    }\n    if (fps > 0) {\n        yieldInterval = Math.floor(1000 / fps);\n    }\n    else {\n        // reset the framerate\n        yieldInterval = 5;\n    }\n    // be aware of browser housekeeping work (~6ms per frame)\n    // according to https://developers.google.com/web/fundamentals/performance/rendering\n    yieldInterval = Math.max(5, yieldInterval - 6);\n}\nconst performWorkUntilDeadline = () => {\n    if (scheduledHostCallback !== null) {\n        const currentTime = getCurrentTime();\n        // Yield after `yieldInterval` ms, regardless of where we are in the vsync\n        // cycle. This means there's always time remaining at the beginning of\n        // the message event.\n        queueStartTime = currentTime;\n        const hasTimeRemaining = true;\n        // If a scheduler task throws, exit the current browser task so the\n        // error can be observed.\n        //\n        // Intentionally not using a try-catch, since that makes some debugging\n        // techniques harder. Instead, if `scheduledHostCallback` errors, then\n        // `hasMoreWork` will remain true, and we'll continue the work loop.\n        let hasMoreWork = true;\n        try {\n            hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);\n        }\n        finally {\n            if (hasMoreWork) {\n                // If there's more work, schedule the next message event at the end\n                // of the preceding one.\n                schedulePerformWorkUntilDeadline();\n            }\n            else {\n                isMessageLoopRunning = false;\n                scheduledHostCallback = null;\n            }\n        }\n    }\n    else {\n        isMessageLoopRunning = false;\n    }\n    // Yielding to the browser will give it a chance to paint, so we can\n    // reset this.\n    needsPaint = false;\n};\nlet schedulePerformWorkUntilDeadline;\nif (typeof setImmediate === 'function') {\n    // Node.js and old IE.\n    // There's a few reasons for why we prefer setImmediate.\n    //\n    // Unlike MessageChannel, it doesn't prevent a Node.js process from exiting.\n    // (Even though this is a DOM fork of the Scheduler, you could get here\n    // with a mix of Node.js 15+, which has a MessageChannel, and jsdom.)\n    // https://github.com/facebook/react/issues/20756\n    //\n    // But also, it runs earlier which is the semantic we want.\n    // If other browsers ever implement it, it's better to use it.\n    // Although both of these would be inferior to native scheduling.\n    schedulePerformWorkUntilDeadline = () => {\n        setImmediate(performWorkUntilDeadline);\n    };\n}\nelse if (typeof messageChannel !== 'undefined') {\n    const channel = new messageChannel();\n    const port = channel.port2;\n    channel.port1.onmessage = performWorkUntilDeadline;\n    schedulePerformWorkUntilDeadline = () => {\n        port.postMessage(null);\n    };\n}\nelse {\n    // We should only fallback here in non-browser environments.\n    schedulePerformWorkUntilDeadline = () => {\n        setTimeout(performWorkUntilDeadline, 0);\n    };\n}\nfunction requestHostCallback(callback) {\n    scheduledHostCallback = callback;\n    if (!isMessageLoopRunning) {\n        isMessageLoopRunning = true;\n        schedulePerformWorkUntilDeadline();\n    }\n}\nfunction requestHostTimeout(callback, ms) {\n    taskTimeoutID = setTimeout(() => {\n        callback(getCurrentTime());\n    }, ms);\n}\nfunction cancelHostTimeout() {\n    clearTimeout(taskTimeoutID);\n    taskTimeoutID = -1;\n}\nconst _requestPaint = requestPaint;\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { cancelCallback, forceFrameRate, scheduleCallback };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}